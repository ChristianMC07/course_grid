"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/sanitize-html";
exports.ids = ["vendor-chunks/sanitize-html"];
exports.modules = {

/***/ "(action-browser)/./node_modules/sanitize-html/index.js":
/*!*********************************************!*\
  !*** ./node_modules/sanitize-html/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst htmlparser = __webpack_require__(/*! htmlparser2 */ \"(action-browser)/./node_modules/htmlparser2/lib/index.js\");\nconst escapeStringRegexp = __webpack_require__(/*! escape-string-regexp */ \"(action-browser)/./node_modules/escape-string-regexp/index.js\");\nconst { isPlainObject } = __webpack_require__(/*! is-plain-object */ \"(action-browser)/./node_modules/is-plain-object/dist/is-plain-object.js\");\nconst deepmerge = __webpack_require__(/*! deepmerge */ \"(action-browser)/./node_modules/deepmerge/dist/cjs.js\");\nconst parseSrcset = __webpack_require__(/*! parse-srcset */ \"(action-browser)/./node_modules/parse-srcset/src/parse-srcset.js\");\nconst { parse: postcssParse } = __webpack_require__(/*! postcss */ \"postcss\");\n// Tags that can conceivably represent stand-alone media.\nconst mediaTags = [\n    \"img\",\n    \"audio\",\n    \"video\",\n    \"picture\",\n    \"svg\",\n    \"object\",\n    \"map\",\n    \"iframe\",\n    \"embed\"\n];\n// Tags that are inherently vulnerable to being used in XSS attacks.\nconst vulnerableTags = [\n    \"script\",\n    \"style\"\n];\nfunction each(obj, cb) {\n    if (obj) {\n        Object.keys(obj).forEach(function(key) {\n            cb(obj[key], key);\n        });\n    }\n}\n// Avoid false positives with .__proto__, .hasOwnProperty, etc.\nfunction has(obj, key) {\n    return ({}).hasOwnProperty.call(obj, key);\n}\n// Returns those elements of `a` for which `cb(a)` returns truthy\nfunction filter(a, cb) {\n    const n = [];\n    each(a, function(v) {\n        if (cb(v)) {\n            n.push(v);\n        }\n    });\n    return n;\n}\nfunction isEmptyObject(obj) {\n    for(const key in obj){\n        if (has(obj, key)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction stringifySrcset(parsedSrcset) {\n    return parsedSrcset.map(function(part) {\n        if (!part.url) {\n            throw new Error(\"URL missing\");\n        }\n        return part.url + (part.w ? ` ${part.w}w` : \"\") + (part.h ? ` ${part.h}h` : \"\") + (part.d ? ` ${part.d}x` : \"\");\n    }).join(\", \");\n}\nmodule.exports = sanitizeHtml;\n// A valid attribute name.\n// We use a tolerant definition based on the set of strings defined by\n// html.spec.whatwg.org/multipage/parsing.html#before-attribute-name-state\n// and html.spec.whatwg.org/multipage/parsing.html#attribute-name-state .\n// The characters accepted are ones which can be appended to the attribute\n// name buffer without triggering a parse error:\n//   * unexpected-equals-sign-before-attribute-name\n//   * unexpected-null-character\n//   * unexpected-character-in-attribute-name\n// We exclude the empty string because it's impossible to get to the after\n// attribute name state with an empty attribute name buffer.\nconst VALID_HTML_ATTRIBUTE_NAME = /^[^\\0\\t\\n\\f\\r /<=>]+$/;\n// Ignore the _recursing flag; it's there for recursive\n// invocation as a guard against this exploit:\n// https://github.com/fb55/htmlparser2/issues/105\nfunction sanitizeHtml(html, options, _recursing) {\n    if (html == null) {\n        return \"\";\n    }\n    if (typeof html === \"number\") {\n        html = html.toString();\n    }\n    let result = \"\";\n    // Used for hot swapping the result variable with an empty string in order to \"capture\" the text written to it.\n    let tempResult = \"\";\n    function Frame(tag, attribs) {\n        const that = this;\n        this.tag = tag;\n        this.attribs = attribs || {};\n        this.tagPosition = result.length;\n        this.text = \"\"; // Node inner text\n        this.mediaChildren = [];\n        this.updateParentNodeText = function() {\n            if (stack.length) {\n                const parentFrame = stack[stack.length - 1];\n                parentFrame.text += that.text;\n            }\n        };\n        this.updateParentNodeMediaChildren = function() {\n            if (stack.length && mediaTags.includes(this.tag)) {\n                const parentFrame = stack[stack.length - 1];\n                parentFrame.mediaChildren.push(this.tag);\n            }\n        };\n    }\n    options = Object.assign({}, sanitizeHtml.defaults, options);\n    options.parser = Object.assign({}, htmlParserDefaults, options.parser);\n    const tagAllowed = function(name) {\n        return options.allowedTags === false || (options.allowedTags || []).indexOf(name) > -1;\n    };\n    // vulnerableTags\n    vulnerableTags.forEach(function(tag) {\n        if (tagAllowed(tag) && !options.allowVulnerableTags) {\n            console.warn(`\\n\\n⚠️ Your \\`allowedTags\\` option includes, \\`${tag}\\`, which is inherently\\nvulnerable to XSS attacks. Please remove it from \\`allowedTags\\`.\\nOr, to disable this warning, add the \\`allowVulnerableTags\\` option\\nand ensure you are accounting for this risk.\\n\\n`);\n        }\n    });\n    // Tags that contain something other than HTML, or where discarding\n    // the text when the tag is disallowed makes sense for other reasons.\n    // If we are not allowing these tags, we should drop their content too.\n    // For other tags you would drop the tag but keep its content.\n    const nonTextTagsArray = options.nonTextTags || [\n        \"script\",\n        \"style\",\n        \"textarea\",\n        \"option\"\n    ];\n    let allowedAttributesMap;\n    let allowedAttributesGlobMap;\n    if (options.allowedAttributes) {\n        allowedAttributesMap = {};\n        allowedAttributesGlobMap = {};\n        each(options.allowedAttributes, function(attributes, tag) {\n            allowedAttributesMap[tag] = [];\n            const globRegex = [];\n            attributes.forEach(function(obj) {\n                if (typeof obj === \"string\" && obj.indexOf(\"*\") >= 0) {\n                    globRegex.push(escapeStringRegexp(obj).replace(/\\\\\\*/g, \".*\"));\n                } else {\n                    allowedAttributesMap[tag].push(obj);\n                }\n            });\n            if (globRegex.length) {\n                allowedAttributesGlobMap[tag] = new RegExp(\"^(\" + globRegex.join(\"|\") + \")$\");\n            }\n        });\n    }\n    const allowedClassesMap = {};\n    const allowedClassesGlobMap = {};\n    const allowedClassesRegexMap = {};\n    each(options.allowedClasses, function(classes, tag) {\n        // Implicitly allows the class attribute\n        if (allowedAttributesMap) {\n            if (!has(allowedAttributesMap, tag)) {\n                allowedAttributesMap[tag] = [];\n            }\n            allowedAttributesMap[tag].push(\"class\");\n        }\n        allowedClassesMap[tag] = classes;\n        if (Array.isArray(classes)) {\n            const globRegex = [];\n            allowedClassesMap[tag] = [];\n            allowedClassesRegexMap[tag] = [];\n            classes.forEach(function(obj) {\n                if (typeof obj === \"string\" && obj.indexOf(\"*\") >= 0) {\n                    globRegex.push(escapeStringRegexp(obj).replace(/\\\\\\*/g, \".*\"));\n                } else if (obj instanceof RegExp) {\n                    allowedClassesRegexMap[tag].push(obj);\n                } else {\n                    allowedClassesMap[tag].push(obj);\n                }\n            });\n            if (globRegex.length) {\n                allowedClassesGlobMap[tag] = new RegExp(\"^(\" + globRegex.join(\"|\") + \")$\");\n            }\n        }\n    });\n    const transformTagsMap = {};\n    let transformTagsAll;\n    each(options.transformTags, function(transform, tag) {\n        let transFun;\n        if (typeof transform === \"function\") {\n            transFun = transform;\n        } else if (typeof transform === \"string\") {\n            transFun = sanitizeHtml.simpleTransform(transform);\n        }\n        if (tag === \"*\") {\n            transformTagsAll = transFun;\n        } else {\n            transformTagsMap[tag] = transFun;\n        }\n    });\n    let depth;\n    let stack;\n    let skipMap;\n    let transformMap;\n    let skipText;\n    let skipTextDepth;\n    let addedText = false;\n    initializeState();\n    const parser = new htmlparser.Parser({\n        onopentag: function(name, attribs) {\n            // If `enforceHtmlBoundary` is `true` and this has found the opening\n            // `html` tag, reset the state.\n            if (options.enforceHtmlBoundary && name === \"html\") {\n                initializeState();\n            }\n            if (skipText) {\n                skipTextDepth++;\n                return;\n            }\n            const frame = new Frame(name, attribs);\n            stack.push(frame);\n            let skip = false;\n            const hasText = !!frame.text;\n            let transformedTag;\n            if (has(transformTagsMap, name)) {\n                transformedTag = transformTagsMap[name](name, attribs);\n                frame.attribs = attribs = transformedTag.attribs;\n                if (transformedTag.text !== undefined) {\n                    frame.innerText = transformedTag.text;\n                }\n                if (name !== transformedTag.tagName) {\n                    frame.name = name = transformedTag.tagName;\n                    transformMap[depth] = transformedTag.tagName;\n                }\n            }\n            if (transformTagsAll) {\n                transformedTag = transformTagsAll(name, attribs);\n                frame.attribs = attribs = transformedTag.attribs;\n                if (name !== transformedTag.tagName) {\n                    frame.name = name = transformedTag.tagName;\n                    transformMap[depth] = transformedTag.tagName;\n                }\n            }\n            if (!tagAllowed(name) || options.disallowedTagsMode === \"recursiveEscape\" && !isEmptyObject(skipMap) || options.nestingLimit != null && depth >= options.nestingLimit) {\n                skip = true;\n                skipMap[depth] = true;\n                if (options.disallowedTagsMode === \"discard\") {\n                    if (nonTextTagsArray.indexOf(name) !== -1) {\n                        skipText = true;\n                        skipTextDepth = 1;\n                    }\n                }\n                skipMap[depth] = true;\n            }\n            depth++;\n            if (skip) {\n                if (options.disallowedTagsMode === \"discard\") {\n                    // We want the contents but not this tag\n                    return;\n                }\n                tempResult = result;\n                result = \"\";\n            }\n            result += \"<\" + name;\n            if (name === \"script\") {\n                if (options.allowedScriptHostnames || options.allowedScriptDomains) {\n                    frame.innerText = \"\";\n                }\n            }\n            if (!allowedAttributesMap || has(allowedAttributesMap, name) || allowedAttributesMap[\"*\"]) {\n                each(attribs, function(value, a) {\n                    if (!VALID_HTML_ATTRIBUTE_NAME.test(a)) {\n                        // This prevents part of an attribute name in the output from being\n                        // interpreted as the end of an attribute, or end of a tag.\n                        delete frame.attribs[a];\n                        return;\n                    }\n                    // If the value is empty, and this is a known non-boolean attribute, delete it\n                    // List taken from https://html.spec.whatwg.org/multipage/indices.html#attributes-3\n                    if (value === \"\" && (options.nonBooleanAttributes.includes(a) || options.nonBooleanAttributes.includes(\"*\"))) {\n                        delete frame.attribs[a];\n                        return;\n                    }\n                    // check allowedAttributesMap for the element and attribute and modify the value\n                    // as necessary if there are specific values defined.\n                    let passedAllowedAttributesMapCheck = false;\n                    if (!allowedAttributesMap || has(allowedAttributesMap, name) && allowedAttributesMap[name].indexOf(a) !== -1 || allowedAttributesMap[\"*\"] && allowedAttributesMap[\"*\"].indexOf(a) !== -1 || has(allowedAttributesGlobMap, name) && allowedAttributesGlobMap[name].test(a) || allowedAttributesGlobMap[\"*\"] && allowedAttributesGlobMap[\"*\"].test(a)) {\n                        passedAllowedAttributesMapCheck = true;\n                    } else if (allowedAttributesMap && allowedAttributesMap[name]) {\n                        for (const o of allowedAttributesMap[name]){\n                            if (isPlainObject(o) && o.name && o.name === a) {\n                                passedAllowedAttributesMapCheck = true;\n                                let newValue = \"\";\n                                if (o.multiple === true) {\n                                    // verify the values that are allowed\n                                    const splitStrArray = value.split(\" \");\n                                    for (const s of splitStrArray){\n                                        if (o.values.indexOf(s) !== -1) {\n                                            if (newValue === \"\") {\n                                                newValue = s;\n                                            } else {\n                                                newValue += \" \" + s;\n                                            }\n                                        }\n                                    }\n                                } else if (o.values.indexOf(value) >= 0) {\n                                    // verified an allowed value matches the entire attribute value\n                                    newValue = value;\n                                }\n                                value = newValue;\n                            }\n                        }\n                    }\n                    if (passedAllowedAttributesMapCheck) {\n                        if (options.allowedSchemesAppliedToAttributes.indexOf(a) !== -1) {\n                            if (naughtyHref(name, value)) {\n                                delete frame.attribs[a];\n                                return;\n                            }\n                        }\n                        if (name === \"script\" && a === \"src\") {\n                            let allowed = true;\n                            try {\n                                const parsed = parseUrl(value);\n                                if (options.allowedScriptHostnames || options.allowedScriptDomains) {\n                                    const allowedHostname = (options.allowedScriptHostnames || []).find(function(hostname) {\n                                        return hostname === parsed.url.hostname;\n                                    });\n                                    const allowedDomain = (options.allowedScriptDomains || []).find(function(domain) {\n                                        return parsed.url.hostname === domain || parsed.url.hostname.endsWith(`.${domain}`);\n                                    });\n                                    allowed = allowedHostname || allowedDomain;\n                                }\n                            } catch (e) {\n                                allowed = false;\n                            }\n                            if (!allowed) {\n                                delete frame.attribs[a];\n                                return;\n                            }\n                        }\n                        if (name === \"iframe\" && a === \"src\") {\n                            let allowed = true;\n                            try {\n                                const parsed = parseUrl(value);\n                                if (parsed.isRelativeUrl) {\n                                    // default value of allowIframeRelativeUrls is true\n                                    // unless allowedIframeHostnames or allowedIframeDomains specified\n                                    allowed = has(options, \"allowIframeRelativeUrls\") ? options.allowIframeRelativeUrls : !options.allowedIframeHostnames && !options.allowedIframeDomains;\n                                } else if (options.allowedIframeHostnames || options.allowedIframeDomains) {\n                                    const allowedHostname = (options.allowedIframeHostnames || []).find(function(hostname) {\n                                        return hostname === parsed.url.hostname;\n                                    });\n                                    const allowedDomain = (options.allowedIframeDomains || []).find(function(domain) {\n                                        return parsed.url.hostname === domain || parsed.url.hostname.endsWith(`.${domain}`);\n                                    });\n                                    allowed = allowedHostname || allowedDomain;\n                                }\n                            } catch (e) {\n                                // Unparseable iframe src\n                                allowed = false;\n                            }\n                            if (!allowed) {\n                                delete frame.attribs[a];\n                                return;\n                            }\n                        }\n                        if (a === \"srcset\") {\n                            try {\n                                let parsed = parseSrcset(value);\n                                parsed.forEach(function(value) {\n                                    if (naughtyHref(\"srcset\", value.url)) {\n                                        value.evil = true;\n                                    }\n                                });\n                                parsed = filter(parsed, function(v) {\n                                    return !v.evil;\n                                });\n                                if (!parsed.length) {\n                                    delete frame.attribs[a];\n                                    return;\n                                } else {\n                                    value = stringifySrcset(filter(parsed, function(v) {\n                                        return !v.evil;\n                                    }));\n                                    frame.attribs[a] = value;\n                                }\n                            } catch (e) {\n                                // Unparseable srcset\n                                delete frame.attribs[a];\n                                return;\n                            }\n                        }\n                        if (a === \"class\") {\n                            const allowedSpecificClasses = allowedClassesMap[name];\n                            const allowedWildcardClasses = allowedClassesMap[\"*\"];\n                            const allowedSpecificClassesGlob = allowedClassesGlobMap[name];\n                            const allowedSpecificClassesRegex = allowedClassesRegexMap[name];\n                            const allowedWildcardClassesGlob = allowedClassesGlobMap[\"*\"];\n                            const allowedClassesGlobs = [\n                                allowedSpecificClassesGlob,\n                                allowedWildcardClassesGlob\n                            ].concat(allowedSpecificClassesRegex).filter(function(t) {\n                                return t;\n                            });\n                            if (allowedSpecificClasses && allowedWildcardClasses) {\n                                value = filterClasses(value, deepmerge(allowedSpecificClasses, allowedWildcardClasses), allowedClassesGlobs);\n                            } else {\n                                value = filterClasses(value, allowedSpecificClasses || allowedWildcardClasses, allowedClassesGlobs);\n                            }\n                            if (!value.length) {\n                                delete frame.attribs[a];\n                                return;\n                            }\n                        }\n                        if (a === \"style\") {\n                            if (options.parseStyleAttributes) {\n                                try {\n                                    const abstractSyntaxTree = postcssParse(name + \" {\" + value + \"}\");\n                                    const filteredAST = filterCss(abstractSyntaxTree, options.allowedStyles);\n                                    value = stringifyStyleAttributes(filteredAST);\n                                    if (value.length === 0) {\n                                        delete frame.attribs[a];\n                                        return;\n                                    }\n                                } catch (e) {\n                                    if (false) {}\n                                    delete frame.attribs[a];\n                                    return;\n                                }\n                            } else if (options.allowedStyles) {\n                                throw new Error(\"allowedStyles option cannot be used together with parseStyleAttributes: false.\");\n                            }\n                        }\n                        result += \" \" + a;\n                        if (value && value.length) {\n                            result += '=\"' + escapeHtml(value, true) + '\"';\n                        }\n                    } else {\n                        delete frame.attribs[a];\n                    }\n                });\n            }\n            if (options.selfClosing.indexOf(name) !== -1) {\n                result += \" />\";\n            } else {\n                result += \">\";\n                if (frame.innerText && !hasText && !options.textFilter) {\n                    result += escapeHtml(frame.innerText);\n                    addedText = true;\n                }\n            }\n            if (skip) {\n                result = tempResult + escapeHtml(result);\n                tempResult = \"\";\n            }\n        },\n        ontext: function(text) {\n            if (skipText) {\n                return;\n            }\n            const lastFrame = stack[stack.length - 1];\n            let tag;\n            if (lastFrame) {\n                tag = lastFrame.tag;\n                // If inner text was set by transform function then let's use it\n                text = lastFrame.innerText !== undefined ? lastFrame.innerText : text;\n            }\n            if (options.disallowedTagsMode === \"discard\" && (tag === \"script\" || tag === \"style\")) {\n                // htmlparser2 gives us these as-is. Escaping them ruins the content. Allowing\n                // script tags is, by definition, game over for XSS protection, so if that's\n                // your concern, don't allow them. The same is essentially true for style tags\n                // which have their own collection of XSS vectors.\n                result += text;\n            } else {\n                const escaped = escapeHtml(text, false);\n                if (options.textFilter && !addedText) {\n                    result += options.textFilter(escaped, tag);\n                } else if (!addedText) {\n                    result += escaped;\n                }\n            }\n            if (stack.length) {\n                const frame = stack[stack.length - 1];\n                frame.text += text;\n            }\n        },\n        onclosetag: function(name, isImplied) {\n            if (skipText) {\n                skipTextDepth--;\n                if (!skipTextDepth) {\n                    skipText = false;\n                } else {\n                    return;\n                }\n            }\n            const frame = stack.pop();\n            if (!frame) {\n                // Do not crash on bad markup\n                return;\n            }\n            if (frame.tag !== name) {\n                // Another case of bad markup.\n                // Push to stack, so that it will be used in future closing tags.\n                stack.push(frame);\n                return;\n            }\n            skipText = options.enforceHtmlBoundary ? name === \"html\" : false;\n            depth--;\n            const skip = skipMap[depth];\n            if (skip) {\n                delete skipMap[depth];\n                if (options.disallowedTagsMode === \"discard\") {\n                    frame.updateParentNodeText();\n                    return;\n                }\n                tempResult = result;\n                result = \"\";\n            }\n            if (transformMap[depth]) {\n                name = transformMap[depth];\n                delete transformMap[depth];\n            }\n            if (options.exclusiveFilter && options.exclusiveFilter(frame)) {\n                result = result.substr(0, frame.tagPosition);\n                return;\n            }\n            frame.updateParentNodeMediaChildren();\n            frame.updateParentNodeText();\n            if (// Already output />\n            options.selfClosing.indexOf(name) !== -1 || // Escaped tag, closing tag is implied\n            isImplied && !tagAllowed(name) && [\n                \"escape\",\n                \"recursiveEscape\"\n            ].indexOf(options.disallowedTagsMode) >= 0) {\n                if (skip) {\n                    result = tempResult;\n                    tempResult = \"\";\n                }\n                return;\n            }\n            result += \"</\" + name + \">\";\n            if (skip) {\n                result = tempResult + escapeHtml(result);\n                tempResult = \"\";\n            }\n            addedText = false;\n        }\n    }, options.parser);\n    parser.write(html);\n    parser.end();\n    return result;\n    function initializeState() {\n        result = \"\";\n        depth = 0;\n        stack = [];\n        skipMap = {};\n        transformMap = {};\n        skipText = false;\n        skipTextDepth = 0;\n    }\n    function escapeHtml(s, quote) {\n        if (typeof s !== \"string\") {\n            s = s + \"\";\n        }\n        if (options.parser.decodeEntities) {\n            s = s.replace(/&/g, \"&amp;\").replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\");\n            if (quote) {\n                s = s.replace(/\"/g, \"&quot;\");\n            }\n        }\n        // TODO: this is inadequate because it will pass `&0;`. This approach\n        // will not work, each & must be considered with regard to whether it\n        // is followed by a 100% syntactically valid entity or not, and escaped\n        // if it is not. If this bothers you, don't set parser.decodeEntities\n        // to false. (The default is true.)\n        s = s.replace(/&(?![a-zA-Z0-9#]{1,20};)/g, \"&amp;\") // Match ampersands not part of existing HTML entity\n        .replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\");\n        if (quote) {\n            s = s.replace(/\"/g, \"&quot;\");\n        }\n        return s;\n    }\n    function naughtyHref(name, href) {\n        // Browsers ignore character codes of 32 (space) and below in a surprising\n        // number of situations. Start reading here:\n        // https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet#Embedded_tab\n        // eslint-disable-next-line no-control-regex\n        href = href.replace(/[\\x00-\\x20]+/g, \"\");\n        // Clobber any comments in URLs, which the browser might\n        // interpret inside an XML data island, allowing\n        // a javascript: URL to be snuck through\n        while(true){\n            const firstIndex = href.indexOf(\"<!--\");\n            if (firstIndex === -1) {\n                break;\n            }\n            const lastIndex = href.indexOf(\"-->\", firstIndex + 4);\n            if (lastIndex === -1) {\n                break;\n            }\n            href = href.substring(0, firstIndex) + href.substring(lastIndex + 3);\n        }\n        // Case insensitive so we don't get faked out by JAVASCRIPT #1\n        // Allow more characters after the first so we don't get faked\n        // out by certain schemes browsers accept\n        const matches = href.match(/^([a-zA-Z][a-zA-Z0-9.\\-+]*):/);\n        if (!matches) {\n            // Protocol-relative URL starting with any combination of '/' and '\\'\n            if (href.match(/^[/\\\\]{2}/)) {\n                return !options.allowProtocolRelative;\n            }\n            // No scheme\n            return false;\n        }\n        const scheme = matches[1].toLowerCase();\n        if (has(options.allowedSchemesByTag, name)) {\n            return options.allowedSchemesByTag[name].indexOf(scheme) === -1;\n        }\n        return !options.allowedSchemes || options.allowedSchemes.indexOf(scheme) === -1;\n    }\n    function parseUrl(value) {\n        value = value.replace(/^(\\w+:)?\\s*[\\\\/]\\s*[\\\\/]/, \"$1//\");\n        if (value.startsWith(\"relative:\")) {\n            // An attempt to exploit our workaround for base URLs being\n            // mandatory for relative URL validation in the WHATWG\n            // URL parser, reject it\n            throw new Error(\"relative: exploit attempt\");\n        }\n        // naughtyHref is in charge of whether protocol relative URLs\n        // are cool. Here we are concerned just with allowed hostnames and\n        // whether to allow relative URLs.\n        //\n        // Build a placeholder \"base URL\" against which any reasonable\n        // relative URL may be parsed successfully\n        let base = \"relative://relative-site\";\n        for(let i = 0; i < 100; i++){\n            base += `/${i}`;\n        }\n        const parsed = new URL(value, base);\n        const isRelativeUrl = parsed && parsed.hostname === \"relative-site\" && parsed.protocol === \"relative:\";\n        return {\n            isRelativeUrl,\n            url: parsed\n        };\n    }\n    /**\n   * Filters user input css properties by allowlisted regex attributes.\n   * Modifies the abstractSyntaxTree object.\n   *\n   * @param {object} abstractSyntaxTree  - Object representation of CSS attributes.\n   * @property {array[Declaration]} abstractSyntaxTree.nodes[0] - Each object cointains prop and value key, i.e { prop: 'color', value: 'red' }.\n   * @param {object} allowedStyles       - Keys are properties (i.e color), value is list of permitted regex rules (i.e /green/i).\n   * @return {object}                    - The modified tree.\n   */ function filterCss(abstractSyntaxTree, allowedStyles) {\n        if (!allowedStyles) {\n            return abstractSyntaxTree;\n        }\n        const astRules = abstractSyntaxTree.nodes[0];\n        let selectedRule;\n        // Merge global and tag-specific styles into new AST.\n        if (allowedStyles[astRules.selector] && allowedStyles[\"*\"]) {\n            selectedRule = deepmerge(allowedStyles[astRules.selector], allowedStyles[\"*\"]);\n        } else {\n            selectedRule = allowedStyles[astRules.selector] || allowedStyles[\"*\"];\n        }\n        if (selectedRule) {\n            abstractSyntaxTree.nodes[0].nodes = astRules.nodes.reduce(filterDeclarations(selectedRule), []);\n        }\n        return abstractSyntaxTree;\n    }\n    /**\n   * Extracts the style attributes from an AbstractSyntaxTree and formats those\n   * values in the inline style attribute format.\n   *\n   * @param  {AbstractSyntaxTree} filteredAST\n   * @return {string}             - Example: \"color:yellow;text-align:center !important;font-family:helvetica;\"\n   */ function stringifyStyleAttributes(filteredAST) {\n        return filteredAST.nodes[0].nodes.reduce(function(extractedAttributes, attrObject) {\n            extractedAttributes.push(`${attrObject.prop}:${attrObject.value}${attrObject.important ? \" !important\" : \"\"}`);\n            return extractedAttributes;\n        }, []).join(\";\");\n    }\n    /**\n    * Filters the existing attributes for the given property. Discards any attributes\n    * which don't match the allowlist.\n    *\n    * @param  {object} selectedRule             - Example: { color: red, font-family: helvetica }\n    * @param  {array} allowedDeclarationsList   - List of declarations which pass the allowlist.\n    * @param  {object} attributeObject          - Object representing the current css property.\n    * @property {string} attributeObject.type   - Typically 'declaration'.\n    * @property {string} attributeObject.prop   - The CSS property, i.e 'color'.\n    * @property {string} attributeObject.value  - The corresponding value to the css property, i.e 'red'.\n    * @return {function}                        - When used in Array.reduce, will return an array of Declaration objects\n    */ function filterDeclarations(selectedRule) {\n        return function(allowedDeclarationsList, attributeObject) {\n            // If this property is allowlisted...\n            if (has(selectedRule, attributeObject.prop)) {\n                const matchesRegex = selectedRule[attributeObject.prop].some(function(regularExpression) {\n                    return regularExpression.test(attributeObject.value);\n                });\n                if (matchesRegex) {\n                    allowedDeclarationsList.push(attributeObject);\n                }\n            }\n            return allowedDeclarationsList;\n        };\n    }\n    function filterClasses(classes, allowed, allowedGlobs) {\n        if (!allowed) {\n            // The class attribute is allowed without filtering on this tag\n            return classes;\n        }\n        classes = classes.split(/\\s+/);\n        return classes.filter(function(clss) {\n            return allowed.indexOf(clss) !== -1 || allowedGlobs.some(function(glob) {\n                return glob.test(clss);\n            });\n        }).join(\" \");\n    }\n}\n// Defaults are accessible to you so that you can use them as a starting point\n// programmatically if you wish\nconst htmlParserDefaults = {\n    decodeEntities: true\n};\nsanitizeHtml.defaults = {\n    allowedTags: [\n        // Sections derived from MDN element categories and limited to the more\n        // benign categories.\n        // https://developer.mozilla.org/en-US/docs/Web/HTML/Element\n        // Content sectioning\n        \"address\",\n        \"article\",\n        \"aside\",\n        \"footer\",\n        \"header\",\n        \"h1\",\n        \"h2\",\n        \"h3\",\n        \"h4\",\n        \"h5\",\n        \"h6\",\n        \"hgroup\",\n        \"main\",\n        \"nav\",\n        \"section\",\n        // Text content\n        \"blockquote\",\n        \"dd\",\n        \"div\",\n        \"dl\",\n        \"dt\",\n        \"figcaption\",\n        \"figure\",\n        \"hr\",\n        \"li\",\n        \"main\",\n        \"ol\",\n        \"p\",\n        \"pre\",\n        \"ul\",\n        // Inline text semantics\n        \"a\",\n        \"abbr\",\n        \"b\",\n        \"bdi\",\n        \"bdo\",\n        \"br\",\n        \"cite\",\n        \"code\",\n        \"data\",\n        \"dfn\",\n        \"em\",\n        \"i\",\n        \"kbd\",\n        \"mark\",\n        \"q\",\n        \"rb\",\n        \"rp\",\n        \"rt\",\n        \"rtc\",\n        \"ruby\",\n        \"s\",\n        \"samp\",\n        \"small\",\n        \"span\",\n        \"strong\",\n        \"sub\",\n        \"sup\",\n        \"time\",\n        \"u\",\n        \"var\",\n        \"wbr\",\n        // Table content\n        \"caption\",\n        \"col\",\n        \"colgroup\",\n        \"table\",\n        \"tbody\",\n        \"td\",\n        \"tfoot\",\n        \"th\",\n        \"thead\",\n        \"tr\"\n    ],\n    // Tags that cannot be boolean\n    nonBooleanAttributes: [\n        \"abbr\",\n        \"accept\",\n        \"accept-charset\",\n        \"accesskey\",\n        \"action\",\n        \"allow\",\n        \"alt\",\n        \"as\",\n        \"autocapitalize\",\n        \"autocomplete\",\n        \"blocking\",\n        \"charset\",\n        \"cite\",\n        \"class\",\n        \"color\",\n        \"cols\",\n        \"colspan\",\n        \"content\",\n        \"contenteditable\",\n        \"coords\",\n        \"crossorigin\",\n        \"data\",\n        \"datetime\",\n        \"decoding\",\n        \"dir\",\n        \"dirname\",\n        \"download\",\n        \"draggable\",\n        \"enctype\",\n        \"enterkeyhint\",\n        \"fetchpriority\",\n        \"for\",\n        \"form\",\n        \"formaction\",\n        \"formenctype\",\n        \"formmethod\",\n        \"formtarget\",\n        \"headers\",\n        \"height\",\n        \"hidden\",\n        \"high\",\n        \"href\",\n        \"hreflang\",\n        \"http-equiv\",\n        \"id\",\n        \"imagesizes\",\n        \"imagesrcset\",\n        \"inputmode\",\n        \"integrity\",\n        \"is\",\n        \"itemid\",\n        \"itemprop\",\n        \"itemref\",\n        \"itemtype\",\n        \"kind\",\n        \"label\",\n        \"lang\",\n        \"list\",\n        \"loading\",\n        \"low\",\n        \"max\",\n        \"maxlength\",\n        \"media\",\n        \"method\",\n        \"min\",\n        \"minlength\",\n        \"name\",\n        \"nonce\",\n        \"optimum\",\n        \"pattern\",\n        \"ping\",\n        \"placeholder\",\n        \"popover\",\n        \"popovertarget\",\n        \"popovertargetaction\",\n        \"poster\",\n        \"preload\",\n        \"referrerpolicy\",\n        \"rel\",\n        \"rows\",\n        \"rowspan\",\n        \"sandbox\",\n        \"scope\",\n        \"shape\",\n        \"size\",\n        \"sizes\",\n        \"slot\",\n        \"span\",\n        \"spellcheck\",\n        \"src\",\n        \"srcdoc\",\n        \"srclang\",\n        \"srcset\",\n        \"start\",\n        \"step\",\n        \"style\",\n        \"tabindex\",\n        \"target\",\n        \"title\",\n        \"translate\",\n        \"type\",\n        \"usemap\",\n        \"value\",\n        \"width\",\n        \"wrap\",\n        // Event handlers\n        \"onauxclick\",\n        \"onafterprint\",\n        \"onbeforematch\",\n        \"onbeforeprint\",\n        \"onbeforeunload\",\n        \"onbeforetoggle\",\n        \"onblur\",\n        \"oncancel\",\n        \"oncanplay\",\n        \"oncanplaythrough\",\n        \"onchange\",\n        \"onclick\",\n        \"onclose\",\n        \"oncontextlost\",\n        \"oncontextmenu\",\n        \"oncontextrestored\",\n        \"oncopy\",\n        \"oncuechange\",\n        \"oncut\",\n        \"ondblclick\",\n        \"ondrag\",\n        \"ondragend\",\n        \"ondragenter\",\n        \"ondragleave\",\n        \"ondragover\",\n        \"ondragstart\",\n        \"ondrop\",\n        \"ondurationchange\",\n        \"onemptied\",\n        \"onended\",\n        \"onerror\",\n        \"onfocus\",\n        \"onformdata\",\n        \"onhashchange\",\n        \"oninput\",\n        \"oninvalid\",\n        \"onkeydown\",\n        \"onkeypress\",\n        \"onkeyup\",\n        \"onlanguagechange\",\n        \"onload\",\n        \"onloadeddata\",\n        \"onloadedmetadata\",\n        \"onloadstart\",\n        \"onmessage\",\n        \"onmessageerror\",\n        \"onmousedown\",\n        \"onmouseenter\",\n        \"onmouseleave\",\n        \"onmousemove\",\n        \"onmouseout\",\n        \"onmouseover\",\n        \"onmouseup\",\n        \"onoffline\",\n        \"ononline\",\n        \"onpagehide\",\n        \"onpageshow\",\n        \"onpaste\",\n        \"onpause\",\n        \"onplay\",\n        \"onplaying\",\n        \"onpopstate\",\n        \"onprogress\",\n        \"onratechange\",\n        \"onreset\",\n        \"onresize\",\n        \"onrejectionhandled\",\n        \"onscroll\",\n        \"onscrollend\",\n        \"onsecuritypolicyviolation\",\n        \"onseeked\",\n        \"onseeking\",\n        \"onselect\",\n        \"onslotchange\",\n        \"onstalled\",\n        \"onstorage\",\n        \"onsubmit\",\n        \"onsuspend\",\n        \"ontimeupdate\",\n        \"ontoggle\",\n        \"onunhandledrejection\",\n        \"onunload\",\n        \"onvolumechange\",\n        \"onwaiting\",\n        \"onwheel\"\n    ],\n    disallowedTagsMode: \"discard\",\n    allowedAttributes: {\n        a: [\n            \"href\",\n            \"name\",\n            \"target\"\n        ],\n        // We don't currently allow img itself by default, but\n        // these attributes would make sense if we did.\n        img: [\n            \"src\",\n            \"srcset\",\n            \"alt\",\n            \"title\",\n            \"width\",\n            \"height\",\n            \"loading\"\n        ]\n    },\n    // Lots of these won't come up by default because we don't allow them\n    selfClosing: [\n        \"img\",\n        \"br\",\n        \"hr\",\n        \"area\",\n        \"base\",\n        \"basefont\",\n        \"input\",\n        \"link\",\n        \"meta\"\n    ],\n    // URL schemes we permit\n    allowedSchemes: [\n        \"http\",\n        \"https\",\n        \"ftp\",\n        \"mailto\",\n        \"tel\"\n    ],\n    allowedSchemesByTag: {},\n    allowedSchemesAppliedToAttributes: [\n        \"href\",\n        \"src\",\n        \"cite\"\n    ],\n    allowProtocolRelative: true,\n    enforceHtmlBoundary: false,\n    parseStyleAttributes: true\n};\nsanitizeHtml.simpleTransform = function(newTagName, newAttribs, merge) {\n    merge = merge === undefined ? true : merge;\n    newAttribs = newAttribs || {};\n    return function(tagName, attribs) {\n        let attrib;\n        if (merge) {\n            for(attrib in newAttribs){\n                attribs[attrib] = newAttribs[attrib];\n            }\n        } else {\n            attribs = newAttribs;\n        }\n        return {\n            tagName: newTagName,\n            attribs: attribs\n        };\n    };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zYW5pdGl6ZS1odG1sL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7QUFBQSxNQUFNQSxhQUFhQyxtQkFBT0EsQ0FBQztBQUMzQixNQUFNQyxxQkFBcUJELG1CQUFPQSxDQUFDO0FBQ25DLE1BQU0sRUFBRUUsYUFBYSxFQUFFLEdBQUdGLG1CQUFPQSxDQUFDO0FBQ2xDLE1BQU1HLFlBQVlILG1CQUFPQSxDQUFDO0FBQzFCLE1BQU1JLGNBQWNKLG1CQUFPQSxDQUFDO0FBQzVCLE1BQU0sRUFBRUssT0FBT0MsWUFBWSxFQUFFLEdBQUdOLG1CQUFPQSxDQUFDO0FBQ3hDLHlEQUF5RDtBQUN6RCxNQUFNTyxZQUFZO0lBQ2hCO0lBQU87SUFBUztJQUFTO0lBQVc7SUFDcEM7SUFBVTtJQUFPO0lBQVU7Q0FDNUI7QUFDRCxvRUFBb0U7QUFDcEUsTUFBTUMsaUJBQWlCO0lBQUU7SUFBVTtDQUFTO0FBRTVDLFNBQVNDLEtBQUtDLEdBQUcsRUFBRUMsRUFBRTtJQUNuQixJQUFJRCxLQUFLO1FBQ1BFLE9BQU9DLElBQUksQ0FBQ0gsS0FBS0ksT0FBTyxDQUFDLFNBQVVDLEdBQUc7WUFDcENKLEdBQUdELEdBQUcsQ0FBQ0ssSUFBSSxFQUFFQTtRQUNmO0lBQ0Y7QUFDRjtBQUVBLCtEQUErRDtBQUMvRCxTQUFTQyxJQUFJTixHQUFHLEVBQUVLLEdBQUc7SUFDbkIsT0FBTyxDQUFDLENBQUMsR0FBR0UsY0FBYyxDQUFDQyxJQUFJLENBQUNSLEtBQUtLO0FBQ3ZDO0FBRUEsaUVBQWlFO0FBQ2pFLFNBQVNJLE9BQU9DLENBQUMsRUFBRVQsRUFBRTtJQUNuQixNQUFNVSxJQUFJLEVBQUU7SUFDWlosS0FBS1csR0FBRyxTQUFTRSxDQUFDO1FBQ2hCLElBQUlYLEdBQUdXLElBQUk7WUFDVEQsRUFBRUUsSUFBSSxDQUFDRDtRQUNUO0lBQ0Y7SUFDQSxPQUFPRDtBQUNUO0FBRUEsU0FBU0csY0FBY2QsR0FBRztJQUN4QixJQUFLLE1BQU1L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cnNlX2dyaWQvLi9ub2RlX21vZHVsZXMvc2FuaXRpemUtaHRtbC9pbmRleC5qcz9kNTYzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGh0bWxwYXJzZXIgPSByZXF1aXJlKCdodG1scGFyc2VyMicpO1xuY29uc3QgZXNjYXBlU3RyaW5nUmVnZXhwID0gcmVxdWlyZSgnZXNjYXBlLXN0cmluZy1yZWdleHAnKTtcbmNvbnN0IHsgaXNQbGFpbk9iamVjdCB9ID0gcmVxdWlyZSgnaXMtcGxhaW4tb2JqZWN0Jyk7XG5jb25zdCBkZWVwbWVyZ2UgPSByZXF1aXJlKCdkZWVwbWVyZ2UnKTtcbmNvbnN0IHBhcnNlU3Jjc2V0ID0gcmVxdWlyZSgncGFyc2Utc3Jjc2V0Jyk7XG5jb25zdCB7IHBhcnNlOiBwb3N0Y3NzUGFyc2UgfSA9IHJlcXVpcmUoJ3Bvc3Rjc3MnKTtcbi8vIFRhZ3MgdGhhdCBjYW4gY29uY2VpdmFibHkgcmVwcmVzZW50IHN0YW5kLWFsb25lIG1lZGlhLlxuY29uc3QgbWVkaWFUYWdzID0gW1xuICAnaW1nJywgJ2F1ZGlvJywgJ3ZpZGVvJywgJ3BpY3R1cmUnLCAnc3ZnJyxcbiAgJ29iamVjdCcsICdtYXAnLCAnaWZyYW1lJywgJ2VtYmVkJ1xuXTtcbi8vIFRhZ3MgdGhhdCBhcmUgaW5oZXJlbnRseSB2dWxuZXJhYmxlIHRvIGJlaW5nIHVzZWQgaW4gWFNTIGF0dGFja3MuXG5jb25zdCB2dWxuZXJhYmxlVGFncyA9IFsgJ3NjcmlwdCcsICdzdHlsZScgXTtcblxuZnVuY3Rpb24gZWFjaChvYmosIGNiKSB7XG4gIGlmIChvYmopIHtcbiAgICBPYmplY3Qua2V5cyhvYmopLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgY2Iob2JqW2tleV0sIGtleSk7XG4gICAgfSk7XG4gIH1cbn1cblxuLy8gQXZvaWQgZmFsc2UgcG9zaXRpdmVzIHdpdGggLl9fcHJvdG9fXywgLmhhc093blByb3BlcnR5LCBldGMuXG5mdW5jdGlvbiBoYXMob2JqLCBrZXkpIHtcbiAgcmV0dXJuICh7fSkuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSk7XG59XG5cbi8vIFJldHVybnMgdGhvc2UgZWxlbWVudHMgb2YgYGFgIGZvciB3aGljaCBgY2IoYSlgIHJldHVybnMgdHJ1dGh5XG5mdW5jdGlvbiBmaWx0ZXIoYSwgY2IpIHtcbiAgY29uc3QgbiA9IFtdO1xuICBlYWNoKGEsIGZ1bmN0aW9uKHYpIHtcbiAgICBpZiAoY2IodikpIHtcbiAgICAgIG4ucHVzaCh2KTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gbjtcbn1cblxuZnVuY3Rpb24gaXNFbXB0eU9iamVjdChvYmopIHtcbiAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKGhhcyhvYmosIGtleSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeVNyY3NldChwYXJzZWRTcmNzZXQpIHtcbiAgcmV0dXJuIHBhcnNlZFNyY3NldC5tYXAoZnVuY3Rpb24ocGFydCkge1xuICAgIGlmICghcGFydC51cmwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVVJMIG1pc3NpbmcnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gKFxuICAgICAgcGFydC51cmwgK1xuICAgICAgKHBhcnQudyA/IGAgJHtwYXJ0Lnd9d2AgOiAnJykgK1xuICAgICAgKHBhcnQuaCA/IGAgJHtwYXJ0Lmh9aGAgOiAnJykgK1xuICAgICAgKHBhcnQuZCA/IGAgJHtwYXJ0LmR9eGAgOiAnJylcbiAgICApO1xuICB9KS5qb2luKCcsICcpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNhbml0aXplSHRtbDtcblxuLy8gQSB2YWxpZCBhdHRyaWJ1dGUgbmFtZS5cbi8vIFdlIHVzZSBhIHRvbGVyYW50IGRlZmluaXRpb24gYmFzZWQgb24gdGhlIHNldCBvZiBzdHJpbmdzIGRlZmluZWQgYnlcbi8vIGh0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9wYXJzaW5nLmh0bWwjYmVmb3JlLWF0dHJpYnV0ZS1uYW1lLXN0YXRlXG4vLyBhbmQgaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3BhcnNpbmcuaHRtbCNhdHRyaWJ1dGUtbmFtZS1zdGF0ZSAuXG4vLyBUaGUgY2hhcmFjdGVycyBhY2NlcHRlZCBhcmUgb25lcyB3aGljaCBjYW4gYmUgYXBwZW5kZWQgdG8gdGhlIGF0dHJpYnV0ZVxuLy8gbmFtZSBidWZmZXIgd2l0aG91dCB0cmlnZ2VyaW5nIGEgcGFyc2UgZXJyb3I6XG4vLyAgICogdW5leHBlY3RlZC1lcXVhbHMtc2lnbi1iZWZvcmUtYXR0cmlidXRlLW5hbWVcbi8vICAgKiB1bmV4cGVjdGVkLW51bGwtY2hhcmFjdGVyXG4vLyAgICogdW5leHBlY3RlZC1jaGFyYWN0ZXItaW4tYXR0cmlidXRlLW5hbWVcbi8vIFdlIGV4Y2x1ZGUgdGhlIGVtcHR5IHN0cmluZyBiZWNhdXNlIGl0J3MgaW1wb3NzaWJsZSB0byBnZXQgdG8gdGhlIGFmdGVyXG4vLyBhdHRyaWJ1dGUgbmFtZSBzdGF0ZSB3aXRoIGFuIGVtcHR5IGF0dHJpYnV0ZSBuYW1lIGJ1ZmZlci5cbmNvbnN0IFZBTElEX0hUTUxfQVRUUklCVVRFX05BTUUgPSAvXlteXFwwXFx0XFxuXFxmXFxyIC88PT5dKyQvO1xuXG4vLyBJZ25vcmUgdGhlIF9yZWN1cnNpbmcgZmxhZzsgaXQncyB0aGVyZSBmb3IgcmVjdXJzaXZlXG4vLyBpbnZvY2F0aW9uIGFzIGEgZ3VhcmQgYWdhaW5zdCB0aGlzIGV4cGxvaXQ6XG4vLyBodHRwczovL2dpdGh1Yi5jb20vZmI1NS9odG1scGFyc2VyMi9pc3N1ZXMvMTA1XG5cbmZ1bmN0aW9uIHNhbml0aXplSHRtbChodG1sLCBvcHRpb25zLCBfcmVjdXJzaW5nKSB7XG4gIGlmIChodG1sID09IG51bGwpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cbiAgaWYgKHR5cGVvZiBodG1sID09PSAnbnVtYmVyJykge1xuICAgIGh0bWwgPSBodG1sLnRvU3RyaW5nKCk7XG4gIH1cblxuICBsZXQgcmVzdWx0ID0gJyc7XG4gIC8vIFVzZWQgZm9yIGhvdCBzd2FwcGluZyB0aGUgcmVzdWx0IHZhcmlhYmxlIHdpdGggYW4gZW1wdHkgc3RyaW5nIGluIG9yZGVyIHRvIFwiY2FwdHVyZVwiIHRoZSB0ZXh0IHdyaXR0ZW4gdG8gaXQuXG4gIGxldCB0ZW1wUmVzdWx0ID0gJyc7XG5cbiAgZnVuY3Rpb24gRnJhbWUodGFnLCBhdHRyaWJzKSB7XG4gICAgY29uc3QgdGhhdCA9IHRoaXM7XG4gICAgdGhpcy50YWcgPSB0YWc7XG4gICAgdGhpcy5hdHRyaWJzID0gYXR0cmlicyB8fCB7fTtcbiAgICB0aGlzLnRhZ1Bvc2l0aW9uID0gcmVzdWx0Lmxlbmd0aDtcbiAgICB0aGlzLnRleHQgPSAnJzsgLy8gTm9kZSBpbm5lciB0ZXh0XG4gICAgdGhpcy5tZWRpYUNoaWxkcmVuID0gW107XG5cbiAgICB0aGlzLnVwZGF0ZVBhcmVudE5vZGVUZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoc3RhY2subGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHBhcmVudEZyYW1lID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XG4gICAgICAgIHBhcmVudEZyYW1lLnRleHQgKz0gdGhhdC50ZXh0O1xuICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLnVwZGF0ZVBhcmVudE5vZGVNZWRpYUNoaWxkcmVuID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoc3RhY2subGVuZ3RoICYmIG1lZGlhVGFncy5pbmNsdWRlcyh0aGlzLnRhZykpIHtcbiAgICAgICAgY29uc3QgcGFyZW50RnJhbWUgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcbiAgICAgICAgcGFyZW50RnJhbWUubWVkaWFDaGlsZHJlbi5wdXNoKHRoaXMudGFnKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIHNhbml0aXplSHRtbC5kZWZhdWx0cywgb3B0aW9ucyk7XG4gIG9wdGlvbnMucGFyc2VyID0gT2JqZWN0LmFzc2lnbih7fSwgaHRtbFBhcnNlckRlZmF1bHRzLCBvcHRpb25zLnBhcnNlcik7XG5cbiAgY29uc3QgdGFnQWxsb3dlZCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMuYWxsb3dlZFRhZ3MgPT09IGZhbHNlIHx8IChvcHRpb25zLmFsbG93ZWRUYWdzIHx8IFtdKS5pbmRleE9mKG5hbWUpID4gLTE7XG4gIH07XG5cbiAgLy8gdnVsbmVyYWJsZVRhZ3NcbiAgdnVsbmVyYWJsZVRhZ3MuZm9yRWFjaChmdW5jdGlvbiAodGFnKSB7XG4gICAgaWYgKHRhZ0FsbG93ZWQodGFnKSAmJiAhb3B0aW9ucy5hbGxvd1Z1bG5lcmFibGVUYWdzKSB7XG4gICAgICBjb25zb2xlLndhcm4oYFxcblxcbuKaoO+4jyBZb3VyIFxcYGFsbG93ZWRUYWdzXFxgIG9wdGlvbiBpbmNsdWRlcywgXFxgJHt0YWd9XFxgLCB3aGljaCBpcyBpbmhlcmVudGx5XFxudnVsbmVyYWJsZSB0byBYU1MgYXR0YWNrcy4gUGxlYXNlIHJlbW92ZSBpdCBmcm9tIFxcYGFsbG93ZWRUYWdzXFxgLlxcbk9yLCB0byBkaXNhYmxlIHRoaXMgd2FybmluZywgYWRkIHRoZSBcXGBhbGxvd1Z1bG5lcmFibGVUYWdzXFxgIG9wdGlvblxcbmFuZCBlbnN1cmUgeW91IGFyZSBhY2NvdW50aW5nIGZvciB0aGlzIHJpc2suXFxuXFxuYCk7XG4gICAgfVxuICB9KTtcblxuICAvLyBUYWdzIHRoYXQgY29udGFpbiBzb21ldGhpbmcgb3RoZXIgdGhhbiBIVE1MLCBvciB3aGVyZSBkaXNjYXJkaW5nXG4gIC8vIHRoZSB0ZXh0IHdoZW4gdGhlIHRhZyBpcyBkaXNhbGxvd2VkIG1ha2VzIHNlbnNlIGZvciBvdGhlciByZWFzb25zLlxuICAvLyBJZiB3ZSBhcmUgbm90IGFsbG93aW5nIHRoZXNlIHRhZ3MsIHdlIHNob3VsZCBkcm9wIHRoZWlyIGNvbnRlbnQgdG9vLlxuICAvLyBGb3Igb3RoZXIgdGFncyB5b3Ugd291bGQgZHJvcCB0aGUgdGFnIGJ1dCBrZWVwIGl0cyBjb250ZW50LlxuICBjb25zdCBub25UZXh0VGFnc0FycmF5ID0gb3B0aW9ucy5ub25UZXh0VGFncyB8fCBbXG4gICAgJ3NjcmlwdCcsXG4gICAgJ3N0eWxlJyxcbiAgICAndGV4dGFyZWEnLFxuICAgICdvcHRpb24nXG4gIF07XG4gIGxldCBhbGxvd2VkQXR0cmlidXRlc01hcDtcbiAgbGV0IGFsbG93ZWRBdHRyaWJ1dGVzR2xvYk1hcDtcbiAgaWYgKG9wdGlvbnMuYWxsb3dlZEF0dHJpYnV0ZXMpIHtcbiAgICBhbGxvd2VkQXR0cmlidXRlc01hcCA9IHt9O1xuICAgIGFsbG93ZWRBdHRyaWJ1dGVzR2xvYk1hcCA9IHt9O1xuICAgIGVhY2gob3B0aW9ucy5hbGxvd2VkQXR0cmlidXRlcywgZnVuY3Rpb24oYXR0cmlidXRlcywgdGFnKSB7XG4gICAgICBhbGxvd2VkQXR0cmlidXRlc01hcFt0YWddID0gW107XG4gICAgICBjb25zdCBnbG9iUmVnZXggPSBbXTtcbiAgICAgIGF0dHJpYnV0ZXMuZm9yRWFjaChmdW5jdGlvbihvYmopIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvYmogPT09ICdzdHJpbmcnICYmIG9iai5pbmRleE9mKCcqJykgPj0gMCkge1xuICAgICAgICAgIGdsb2JSZWdleC5wdXNoKGVzY2FwZVN0cmluZ1JlZ2V4cChvYmopLnJlcGxhY2UoL1xcXFxcXCovZywgJy4qJykpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFsbG93ZWRBdHRyaWJ1dGVzTWFwW3RhZ10ucHVzaChvYmopO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmIChnbG9iUmVnZXgubGVuZ3RoKSB7XG4gICAgICAgIGFsbG93ZWRBdHRyaWJ1dGVzR2xvYk1hcFt0YWddID0gbmV3IFJlZ0V4cCgnXignICsgZ2xvYlJlZ2V4LmpvaW4oJ3wnKSArICcpJCcpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGNvbnN0IGFsbG93ZWRDbGFzc2VzTWFwID0ge307XG4gIGNvbnN0IGFsbG93ZWRDbGFzc2VzR2xvYk1hcCA9IHt9O1xuICBjb25zdCBhbGxvd2VkQ2xhc3Nlc1JlZ2V4TWFwID0ge307XG4gIGVhY2gob3B0aW9ucy5hbGxvd2VkQ2xhc3NlcywgZnVuY3Rpb24oY2xhc3NlcywgdGFnKSB7XG4gICAgLy8gSW1wbGljaXRseSBhbGxvd3MgdGhlIGNsYXNzIGF0dHJpYnV0ZVxuICAgIGlmIChhbGxvd2VkQXR0cmlidXRlc01hcCkge1xuICAgICAgaWYgKCFoYXMoYWxsb3dlZEF0dHJpYnV0ZXNNYXAsIHRhZykpIHtcbiAgICAgICAgYWxsb3dlZEF0dHJpYnV0ZXNNYXBbdGFnXSA9IFtdO1xuICAgICAgfVxuICAgICAgYWxsb3dlZEF0dHJpYnV0ZXNNYXBbdGFnXS5wdXNoKCdjbGFzcycpO1xuICAgIH1cblxuICAgIGFsbG93ZWRDbGFzc2VzTWFwW3RhZ10gPSBjbGFzc2VzO1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY2xhc3NlcykpIHtcbiAgICAgIGNvbnN0IGdsb2JSZWdleCA9IFtdO1xuICAgICAgYWxsb3dlZENsYXNzZXNNYXBbdGFnXSA9IFtdO1xuICAgICAgYWxsb3dlZENsYXNzZXNSZWdleE1hcFt0YWddID0gW107XG4gICAgICBjbGFzc2VzLmZvckVhY2goZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb2JqID09PSAnc3RyaW5nJyAmJiBvYmouaW5kZXhPZignKicpID49IDApIHtcbiAgICAgICAgICBnbG9iUmVnZXgucHVzaChlc2NhcGVTdHJpbmdSZWdleHAob2JqKS5yZXBsYWNlKC9cXFxcXFwqL2csICcuKicpKTtcbiAgICAgICAgfSBlbHNlIGlmIChvYmogaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgICBhbGxvd2VkQ2xhc3Nlc1JlZ2V4TWFwW3RhZ10ucHVzaChvYmopO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFsbG93ZWRDbGFzc2VzTWFwW3RhZ10ucHVzaChvYmopO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmIChnbG9iUmVnZXgubGVuZ3RoKSB7XG4gICAgICAgIGFsbG93ZWRDbGFzc2VzR2xvYk1hcFt0YWddID0gbmV3IFJlZ0V4cCgnXignICsgZ2xvYlJlZ2V4LmpvaW4oJ3wnKSArICcpJCcpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgY29uc3QgdHJhbnNmb3JtVGFnc01hcCA9IHt9O1xuICBsZXQgdHJhbnNmb3JtVGFnc0FsbDtcbiAgZWFjaChvcHRpb25zLnRyYW5zZm9ybVRhZ3MsIGZ1bmN0aW9uKHRyYW5zZm9ybSwgdGFnKSB7XG4gICAgbGV0IHRyYW5zRnVuO1xuICAgIGlmICh0eXBlb2YgdHJhbnNmb3JtID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0cmFuc0Z1biA9IHRyYW5zZm9ybTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB0cmFuc2Zvcm0gPT09ICdzdHJpbmcnKSB7XG4gICAgICB0cmFuc0Z1biA9IHNhbml0aXplSHRtbC5zaW1wbGVUcmFuc2Zvcm0odHJhbnNmb3JtKTtcbiAgICB9XG4gICAgaWYgKHRhZyA9PT0gJyonKSB7XG4gICAgICB0cmFuc2Zvcm1UYWdzQWxsID0gdHJhbnNGdW47XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyYW5zZm9ybVRhZ3NNYXBbdGFnXSA9IHRyYW5zRnVuO1xuICAgIH1cbiAgfSk7XG5cbiAgbGV0IGRlcHRoO1xuICBsZXQgc3RhY2s7XG4gIGxldCBza2lwTWFwO1xuICBsZXQgdHJhbnNmb3JtTWFwO1xuICBsZXQgc2tpcFRleHQ7XG4gIGxldCBza2lwVGV4dERlcHRoO1xuICBsZXQgYWRkZWRUZXh0ID0gZmFsc2U7XG5cbiAgaW5pdGlhbGl6ZVN0YXRlKCk7XG5cbiAgY29uc3QgcGFyc2VyID0gbmV3IGh0bWxwYXJzZXIuUGFyc2VyKHtcbiAgICBvbm9wZW50YWc6IGZ1bmN0aW9uKG5hbWUsIGF0dHJpYnMpIHtcbiAgICAgIC8vIElmIGBlbmZvcmNlSHRtbEJvdW5kYXJ5YCBpcyBgdHJ1ZWAgYW5kIHRoaXMgaGFzIGZvdW5kIHRoZSBvcGVuaW5nXG4gICAgICAvLyBgaHRtbGAgdGFnLCByZXNldCB0aGUgc3RhdGUuXG4gICAgICBpZiAob3B0aW9ucy5lbmZvcmNlSHRtbEJvdW5kYXJ5ICYmIG5hbWUgPT09ICdodG1sJykge1xuICAgICAgICBpbml0aWFsaXplU3RhdGUoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNraXBUZXh0KSB7XG4gICAgICAgIHNraXBUZXh0RGVwdGgrKztcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgZnJhbWUgPSBuZXcgRnJhbWUobmFtZSwgYXR0cmlicyk7XG4gICAgICBzdGFjay5wdXNoKGZyYW1lKTtcblxuICAgICAgbGV0IHNraXAgPSBmYWxzZTtcbiAgICAgIGNvbnN0IGhhc1RleHQgPSAhIWZyYW1lLnRleHQ7XG4gICAgICBsZXQgdHJhbnNmb3JtZWRUYWc7XG4gICAgICBpZiAoaGFzKHRyYW5zZm9ybVRhZ3NNYXAsIG5hbWUpKSB7XG4gICAgICAgIHRyYW5zZm9ybWVkVGFnID0gdHJhbnNmb3JtVGFnc01hcFtuYW1lXShuYW1lLCBhdHRyaWJzKTtcblxuICAgICAgICBmcmFtZS5hdHRyaWJzID0gYXR0cmlicyA9IHRyYW5zZm9ybWVkVGFnLmF0dHJpYnM7XG5cbiAgICAgICAgaWYgKHRyYW5zZm9ybWVkVGFnLnRleHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGZyYW1lLmlubmVyVGV4dCA9IHRyYW5zZm9ybWVkVGFnLnRleHQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobmFtZSAhPT0gdHJhbnNmb3JtZWRUYWcudGFnTmFtZSkge1xuICAgICAgICAgIGZyYW1lLm5hbWUgPSBuYW1lID0gdHJhbnNmb3JtZWRUYWcudGFnTmFtZTtcbiAgICAgICAgICB0cmFuc2Zvcm1NYXBbZGVwdGhdID0gdHJhbnNmb3JtZWRUYWcudGFnTmFtZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRyYW5zZm9ybVRhZ3NBbGwpIHtcbiAgICAgICAgdHJhbnNmb3JtZWRUYWcgPSB0cmFuc2Zvcm1UYWdzQWxsKG5hbWUsIGF0dHJpYnMpO1xuXG4gICAgICAgIGZyYW1lLmF0dHJpYnMgPSBhdHRyaWJzID0gdHJhbnNmb3JtZWRUYWcuYXR0cmlicztcbiAgICAgICAgaWYgKG5hbWUgIT09IHRyYW5zZm9ybWVkVGFnLnRhZ05hbWUpIHtcbiAgICAgICAgICBmcmFtZS5uYW1lID0gbmFtZSA9IHRyYW5zZm9ybWVkVGFnLnRhZ05hbWU7XG4gICAgICAgICAgdHJhbnNmb3JtTWFwW2RlcHRoXSA9IHRyYW5zZm9ybWVkVGFnLnRhZ05hbWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCF0YWdBbGxvd2VkKG5hbWUpIHx8IChvcHRpb25zLmRpc2FsbG93ZWRUYWdzTW9kZSA9PT0gJ3JlY3Vyc2l2ZUVzY2FwZScgJiYgIWlzRW1wdHlPYmplY3Qoc2tpcE1hcCkpIHx8IChvcHRpb25zLm5lc3RpbmdMaW1pdCAhPSBudWxsICYmIGRlcHRoID49IG9wdGlvbnMubmVzdGluZ0xpbWl0KSkge1xuICAgICAgICBza2lwID0gdHJ1ZTtcbiAgICAgICAgc2tpcE1hcFtkZXB0aF0gPSB0cnVlO1xuICAgICAgICBpZiAob3B0aW9ucy5kaXNhbGxvd2VkVGFnc01vZGUgPT09ICdkaXNjYXJkJykge1xuICAgICAgICAgIGlmIChub25UZXh0VGFnc0FycmF5LmluZGV4T2YobmFtZSkgIT09IC0xKSB7XG4gICAgICAgICAgICBza2lwVGV4dCA9IHRydWU7XG4gICAgICAgICAgICBza2lwVGV4dERlcHRoID0gMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc2tpcE1hcFtkZXB0aF0gPSB0cnVlO1xuICAgICAgfVxuICAgICAgZGVwdGgrKztcbiAgICAgIGlmIChza2lwKSB7XG4gICAgICAgIGlmIChvcHRpb25zLmRpc2FsbG93ZWRUYWdzTW9kZSA9PT0gJ2Rpc2NhcmQnKSB7XG4gICAgICAgICAgLy8gV2Ugd2FudCB0aGUgY29udGVudHMgYnV0IG5vdCB0aGlzIHRhZ1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0ZW1wUmVzdWx0ID0gcmVzdWx0O1xuICAgICAgICByZXN1bHQgPSAnJztcbiAgICAgIH1cbiAgICAgIHJlc3VsdCArPSAnPCcgKyBuYW1lO1xuXG4gICAgICBpZiAobmFtZSA9PT0gJ3NjcmlwdCcpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuYWxsb3dlZFNjcmlwdEhvc3RuYW1lcyB8fCBvcHRpb25zLmFsbG93ZWRTY3JpcHREb21haW5zKSB7XG4gICAgICAgICAgZnJhbWUuaW5uZXJUZXh0ID0gJyc7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFhbGxvd2VkQXR0cmlidXRlc01hcCB8fCBoYXMoYWxsb3dlZEF0dHJpYnV0ZXNNYXAsIG5hbWUpIHx8IGFsbG93ZWRBdHRyaWJ1dGVzTWFwWycqJ10pIHtcbiAgICAgICAgZWFjaChhdHRyaWJzLCBmdW5jdGlvbih2YWx1ZSwgYSkge1xuICAgICAgICAgIGlmICghVkFMSURfSFRNTF9BVFRSSUJVVEVfTkFNRS50ZXN0KGEpKSB7XG4gICAgICAgICAgICAvLyBUaGlzIHByZXZlbnRzIHBhcnQgb2YgYW4gYXR0cmlidXRlIG5hbWUgaW4gdGhlIG91dHB1dCBmcm9tIGJlaW5nXG4gICAgICAgICAgICAvLyBpbnRlcnByZXRlZCBhcyB0aGUgZW5kIG9mIGFuIGF0dHJpYnV0ZSwgb3IgZW5kIG9mIGEgdGFnLlxuICAgICAgICAgICAgZGVsZXRlIGZyYW1lLmF0dHJpYnNbYV07XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIElmIHRoZSB2YWx1ZSBpcyBlbXB0eSwgYW5kIHRoaXMgaXMgYSBrbm93biBub24tYm9vbGVhbiBhdHRyaWJ1dGUsIGRlbGV0ZSBpdFxuICAgICAgICAgIC8vIExpc3QgdGFrZW4gZnJvbSBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9pbmRpY2VzLmh0bWwjYXR0cmlidXRlcy0zXG4gICAgICAgICAgaWYgKHZhbHVlID09PSAnJyAmJiAob3B0aW9ucy5ub25Cb29sZWFuQXR0cmlidXRlcy5pbmNsdWRlcyhhKSB8fCBvcHRpb25zLm5vbkJvb2xlYW5BdHRyaWJ1dGVzLmluY2x1ZGVzKCcqJykpKSB7XG4gICAgICAgICAgICBkZWxldGUgZnJhbWUuYXR0cmlic1thXTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gY2hlY2sgYWxsb3dlZEF0dHJpYnV0ZXNNYXAgZm9yIHRoZSBlbGVtZW50IGFuZCBhdHRyaWJ1dGUgYW5kIG1vZGlmeSB0aGUgdmFsdWVcbiAgICAgICAgICAvLyBhcyBuZWNlc3NhcnkgaWYgdGhlcmUgYXJlIHNwZWNpZmljIHZhbHVlcyBkZWZpbmVkLlxuICAgICAgICAgIGxldCBwYXNzZWRBbGxvd2VkQXR0cmlidXRlc01hcENoZWNrID0gZmFsc2U7XG4gICAgICAgICAgaWYgKCFhbGxvd2VkQXR0cmlidXRlc01hcCB8fFxuICAgICAgICAgICAgKGhhcyhhbGxvd2VkQXR0cmlidXRlc01hcCwgbmFtZSkgJiYgYWxsb3dlZEF0dHJpYnV0ZXNNYXBbbmFtZV0uaW5kZXhPZihhKSAhPT0gLTEpIHx8XG4gICAgICAgICAgICAoYWxsb3dlZEF0dHJpYnV0ZXNNYXBbJyonXSAmJiBhbGxvd2VkQXR0cmlidXRlc01hcFsnKiddLmluZGV4T2YoYSkgIT09IC0xKSB8fFxuICAgICAgICAgICAgKGhhcyhhbGxvd2VkQXR0cmlidXRlc0dsb2JNYXAsIG5hbWUpICYmIGFsbG93ZWRBdHRyaWJ1dGVzR2xvYk1hcFtuYW1lXS50ZXN0KGEpKSB8fFxuICAgICAgICAgICAgKGFsbG93ZWRBdHRyaWJ1dGVzR2xvYk1hcFsnKiddICYmIGFsbG93ZWRBdHRyaWJ1dGVzR2xvYk1hcFsnKiddLnRlc3QoYSkpKSB7XG4gICAgICAgICAgICBwYXNzZWRBbGxvd2VkQXR0cmlidXRlc01hcENoZWNrID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGFsbG93ZWRBdHRyaWJ1dGVzTWFwICYmIGFsbG93ZWRBdHRyaWJ1dGVzTWFwW25hbWVdKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG8gb2YgYWxsb3dlZEF0dHJpYnV0ZXNNYXBbbmFtZV0pIHtcbiAgICAgICAgICAgICAgaWYgKGlzUGxhaW5PYmplY3QobykgJiYgby5uYW1lICYmIChvLm5hbWUgPT09IGEpKSB7XG4gICAgICAgICAgICAgICAgcGFzc2VkQWxsb3dlZEF0dHJpYnV0ZXNNYXBDaGVjayA9IHRydWU7XG4gICAgICAgICAgICAgICAgbGV0IG5ld1ZhbHVlID0gJyc7XG4gICAgICAgICAgICAgICAgaWYgKG8ubXVsdGlwbGUgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgIC8vIHZlcmlmeSB0aGUgdmFsdWVzIHRoYXQgYXJlIGFsbG93ZWRcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHNwbGl0U3RyQXJyYXkgPSB2YWx1ZS5zcGxpdCgnICcpO1xuICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBzIG9mIHNwbGl0U3RyQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG8udmFsdWVzLmluZGV4T2YocykgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKG5ld1ZhbHVlID09PSAnJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3VmFsdWUgPSBzO1xuICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZSArPSAnICcgKyBzO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoby52YWx1ZXMuaW5kZXhPZih2YWx1ZSkgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgLy8gdmVyaWZpZWQgYW4gYWxsb3dlZCB2YWx1ZSBtYXRjaGVzIHRoZSBlbnRpcmUgYXR0cmlidXRlIHZhbHVlXG4gICAgICAgICAgICAgICAgICBuZXdWYWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwYXNzZWRBbGxvd2VkQXR0cmlidXRlc01hcENoZWNrKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5hbGxvd2VkU2NoZW1lc0FwcGxpZWRUb0F0dHJpYnV0ZXMuaW5kZXhPZihhKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgaWYgKG5hdWdodHlIcmVmKG5hbWUsIHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBmcmFtZS5hdHRyaWJzW2FdO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gJ3NjcmlwdCcgJiYgYSA9PT0gJ3NyYycpIHtcblxuICAgICAgICAgICAgICBsZXQgYWxsb3dlZCA9IHRydWU7XG5cbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWQgPSBwYXJzZVVybCh2YWx1ZSk7XG5cbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5hbGxvd2VkU2NyaXB0SG9zdG5hbWVzIHx8IG9wdGlvbnMuYWxsb3dlZFNjcmlwdERvbWFpbnMpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGFsbG93ZWRIb3N0bmFtZSA9IChvcHRpb25zLmFsbG93ZWRTY3JpcHRIb3N0bmFtZXMgfHwgW10pLmZpbmQoZnVuY3Rpb24gKGhvc3RuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBob3N0bmFtZSA9PT0gcGFyc2VkLnVybC5ob3N0bmFtZTtcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgY29uc3QgYWxsb3dlZERvbWFpbiA9IChvcHRpb25zLmFsbG93ZWRTY3JpcHREb21haW5zIHx8IFtdKS5maW5kKGZ1bmN0aW9uKGRvbWFpbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VkLnVybC5ob3N0bmFtZSA9PT0gZG9tYWluIHx8IHBhcnNlZC51cmwuaG9zdG5hbWUuZW5kc1dpdGgoYC4ke2RvbWFpbn1gKTtcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgYWxsb3dlZCA9IGFsbG93ZWRIb3N0bmFtZSB8fCBhbGxvd2VkRG9tYWluO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGFsbG93ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmICghYWxsb3dlZCkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBmcmFtZS5hdHRyaWJzW2FdO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gJ2lmcmFtZScgJiYgYSA9PT0gJ3NyYycpIHtcbiAgICAgICAgICAgICAgbGV0IGFsbG93ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlZCA9IHBhcnNlVXJsKHZhbHVlKTtcblxuICAgICAgICAgICAgICAgIGlmIChwYXJzZWQuaXNSZWxhdGl2ZVVybCkge1xuICAgICAgICAgICAgICAgICAgLy8gZGVmYXVsdCB2YWx1ZSBvZiBhbGxvd0lmcmFtZVJlbGF0aXZlVXJscyBpcyB0cnVlXG4gICAgICAgICAgICAgICAgICAvLyB1bmxlc3MgYWxsb3dlZElmcmFtZUhvc3RuYW1lcyBvciBhbGxvd2VkSWZyYW1lRG9tYWlucyBzcGVjaWZpZWRcbiAgICAgICAgICAgICAgICAgIGFsbG93ZWQgPSBoYXMob3B0aW9ucywgJ2FsbG93SWZyYW1lUmVsYXRpdmVVcmxzJylcbiAgICAgICAgICAgICAgICAgICAgPyBvcHRpb25zLmFsbG93SWZyYW1lUmVsYXRpdmVVcmxzXG4gICAgICAgICAgICAgICAgICAgIDogKCFvcHRpb25zLmFsbG93ZWRJZnJhbWVIb3N0bmFtZXMgJiYgIW9wdGlvbnMuYWxsb3dlZElmcmFtZURvbWFpbnMpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5hbGxvd2VkSWZyYW1lSG9zdG5hbWVzIHx8IG9wdGlvbnMuYWxsb3dlZElmcmFtZURvbWFpbnMpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGFsbG93ZWRIb3N0bmFtZSA9IChvcHRpb25zLmFsbG93ZWRJZnJhbWVIb3N0bmFtZXMgfHwgW10pLmZpbmQoZnVuY3Rpb24gKGhvc3RuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBob3N0bmFtZSA9PT0gcGFyc2VkLnVybC5ob3N0bmFtZTtcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgY29uc3QgYWxsb3dlZERvbWFpbiA9IChvcHRpb25zLmFsbG93ZWRJZnJhbWVEb21haW5zIHx8IFtdKS5maW5kKGZ1bmN0aW9uKGRvbWFpbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VkLnVybC5ob3N0bmFtZSA9PT0gZG9tYWluIHx8IHBhcnNlZC51cmwuaG9zdG5hbWUuZW5kc1dpdGgoYC4ke2RvbWFpbn1gKTtcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgYWxsb3dlZCA9IGFsbG93ZWRIb3N0bmFtZSB8fCBhbGxvd2VkRG9tYWluO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIC8vIFVucGFyc2VhYmxlIGlmcmFtZSBzcmNcbiAgICAgICAgICAgICAgICBhbGxvd2VkID0gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKCFhbGxvd2VkKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGZyYW1lLmF0dHJpYnNbYV07XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYSA9PT0gJ3NyY3NldCcpIHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBsZXQgcGFyc2VkID0gcGFyc2VTcmNzZXQodmFsdWUpO1xuICAgICAgICAgICAgICAgIHBhcnNlZC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICBpZiAobmF1Z2h0eUhyZWYoJ3NyY3NldCcsIHZhbHVlLnVybCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUuZXZpbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcGFyc2VkID0gZmlsdGVyKHBhcnNlZCwgZnVuY3Rpb24odikge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuICF2LmV2aWw7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKCFwYXJzZWQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICBkZWxldGUgZnJhbWUuYXR0cmlic1thXTtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdmFsdWUgPSBzdHJpbmdpZnlTcmNzZXQoZmlsdGVyKHBhcnNlZCwgZnVuY3Rpb24odikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gIXYuZXZpbDtcbiAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgIGZyYW1lLmF0dHJpYnNbYV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAvLyBVbnBhcnNlYWJsZSBzcmNzZXRcbiAgICAgICAgICAgICAgICBkZWxldGUgZnJhbWUuYXR0cmlic1thXTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhID09PSAnY2xhc3MnKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGFsbG93ZWRTcGVjaWZpY0NsYXNzZXMgPSBhbGxvd2VkQ2xhc3Nlc01hcFtuYW1lXTtcbiAgICAgICAgICAgICAgY29uc3QgYWxsb3dlZFdpbGRjYXJkQ2xhc3NlcyA9IGFsbG93ZWRDbGFzc2VzTWFwWycqJ107XG4gICAgICAgICAgICAgIGNvbnN0IGFsbG93ZWRTcGVjaWZpY0NsYXNzZXNHbG9iID0gYWxsb3dlZENsYXNzZXNHbG9iTWFwW25hbWVdO1xuICAgICAgICAgICAgICBjb25zdCBhbGxvd2VkU3BlY2lmaWNDbGFzc2VzUmVnZXggPSBhbGxvd2VkQ2xhc3Nlc1JlZ2V4TWFwW25hbWVdO1xuICAgICAgICAgICAgICBjb25zdCBhbGxvd2VkV2lsZGNhcmRDbGFzc2VzR2xvYiA9IGFsbG93ZWRDbGFzc2VzR2xvYk1hcFsnKiddO1xuICAgICAgICAgICAgICBjb25zdCBhbGxvd2VkQ2xhc3Nlc0dsb2JzID0gW1xuICAgICAgICAgICAgICAgIGFsbG93ZWRTcGVjaWZpY0NsYXNzZXNHbG9iLFxuICAgICAgICAgICAgICAgIGFsbG93ZWRXaWxkY2FyZENsYXNzZXNHbG9iXG4gICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAuY29uY2F0KGFsbG93ZWRTcGVjaWZpY0NsYXNzZXNSZWdleClcbiAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgaWYgKGFsbG93ZWRTcGVjaWZpY0NsYXNzZXMgJiYgYWxsb3dlZFdpbGRjYXJkQ2xhc3Nlcykge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gZmlsdGVyQ2xhc3Nlcyh2YWx1ZSwgZGVlcG1lcmdlKGFsbG93ZWRTcGVjaWZpY0NsYXNzZXMsIGFsbG93ZWRXaWxkY2FyZENsYXNzZXMpLCBhbGxvd2VkQ2xhc3Nlc0dsb2JzKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGZpbHRlckNsYXNzZXModmFsdWUsIGFsbG93ZWRTcGVjaWZpY0NsYXNzZXMgfHwgYWxsb3dlZFdpbGRjYXJkQ2xhc3NlcywgYWxsb3dlZENsYXNzZXNHbG9icyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKCF2YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgZnJhbWUuYXR0cmlic1thXTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhID09PSAnc3R5bGUnKSB7XG4gICAgICAgICAgICAgIGlmIChvcHRpb25zLnBhcnNlU3R5bGVBdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGFic3RyYWN0U3ludGF4VHJlZSA9IHBvc3Rjc3NQYXJzZShuYW1lICsgJyB7JyArIHZhbHVlICsgJ30nKTtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGZpbHRlcmVkQVNUID0gZmlsdGVyQ3NzKGFic3RyYWN0U3ludGF4VHJlZSwgb3B0aW9ucy5hbGxvd2VkU3R5bGVzKTtcblxuICAgICAgICAgICAgICAgICAgdmFsdWUgPSBzdHJpbmdpZnlTdHlsZUF0dHJpYnV0ZXMoZmlsdGVyZWRBU1QpO1xuXG4gICAgICAgICAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBmcmFtZS5hdHRyaWJzW2FdO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignRmFpbGVkIHRvIHBhcnNlIFwiJyArIG5hbWUgKyAnIHsnICsgdmFsdWUgKyAnfScgKyAnXCIsIElmIHlvdVxcJ3JlIHJ1bm5pbmcgdGhpcyBpbiBhIGJyb3dzZXIsIHdlIHJlY29tbWVuZCB0byBkaXNhYmxlIHN0eWxlIHBhcnNpbmc6IG9wdGlvbnMucGFyc2VTdHlsZUF0dHJpYnV0ZXM6IGZhbHNlLCBzaW5jZSB0aGlzIG9ubHkgd29ya3MgaW4gYSBub2RlIGVudmlyb25tZW50IGR1ZSB0byBhIHBvc3Rjc3MgZGVwZW5kZW5jeSwgTW9yZSBpbmZvOiBodHRwczovL2dpdGh1Yi5jb20vYXBvc3Ryb3BoZWNtcy9zYW5pdGl6ZS1odG1sL2lzc3Vlcy81NDcnKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGRlbGV0ZSBmcmFtZS5hdHRyaWJzW2FdO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zLmFsbG93ZWRTdHlsZXMpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FsbG93ZWRTdHlsZXMgb3B0aW9uIGNhbm5vdCBiZSB1c2VkIHRvZ2V0aGVyIHdpdGggcGFyc2VTdHlsZUF0dHJpYnV0ZXM6IGZhbHNlLicpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQgKz0gJyAnICsgYTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAmJiB2YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmVzdWx0ICs9ICc9XCInICsgZXNjYXBlSHRtbCh2YWx1ZSwgdHJ1ZSkgKyAnXCInO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkZWxldGUgZnJhbWUuYXR0cmlic1thXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMuc2VsZkNsb3NpbmcuaW5kZXhPZihuYW1lKSAhPT0gLTEpIHtcbiAgICAgICAgcmVzdWx0ICs9ICcgLz4nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0ICs9ICc+JztcbiAgICAgICAgaWYgKGZyYW1lLmlubmVyVGV4dCAmJiAhaGFzVGV4dCAmJiAhb3B0aW9ucy50ZXh0RmlsdGVyKSB7XG4gICAgICAgICAgcmVzdWx0ICs9IGVzY2FwZUh0bWwoZnJhbWUuaW5uZXJUZXh0KTtcbiAgICAgICAgICBhZGRlZFRleHQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoc2tpcCkge1xuICAgICAgICByZXN1bHQgPSB0ZW1wUmVzdWx0ICsgZXNjYXBlSHRtbChyZXN1bHQpO1xuICAgICAgICB0ZW1wUmVzdWx0ID0gJyc7XG4gICAgICB9XG4gICAgfSxcbiAgICBvbnRleHQ6IGZ1bmN0aW9uKHRleHQpIHtcbiAgICAgIGlmIChza2lwVGV4dCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBsYXN0RnJhbWUgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcbiAgICAgIGxldCB0YWc7XG5cbiAgICAgIGlmIChsYXN0RnJhbWUpIHtcbiAgICAgICAgdGFnID0gbGFzdEZyYW1lLnRhZztcbiAgICAgICAgLy8gSWYgaW5uZXIgdGV4dCB3YXMgc2V0IGJ5IHRyYW5zZm9ybSBmdW5jdGlvbiB0aGVuIGxldCdzIHVzZSBpdFxuICAgICAgICB0ZXh0ID0gbGFzdEZyYW1lLmlubmVyVGV4dCAhPT0gdW5kZWZpbmVkID8gbGFzdEZyYW1lLmlubmVyVGV4dCA6IHRleHQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLmRpc2FsbG93ZWRUYWdzTW9kZSA9PT0gJ2Rpc2NhcmQnICYmICgodGFnID09PSAnc2NyaXB0JykgfHwgKHRhZyA9PT0gJ3N0eWxlJykpKSB7XG4gICAgICAgIC8vIGh0bWxwYXJzZXIyIGdpdmVzIHVzIHRoZXNlIGFzLWlzLiBFc2NhcGluZyB0aGVtIHJ1aW5zIHRoZSBjb250ZW50LiBBbGxvd2luZ1xuICAgICAgICAvLyBzY3JpcHQgdGFncyBpcywgYnkgZGVmaW5pdGlvbiwgZ2FtZSBvdmVyIGZvciBYU1MgcHJvdGVjdGlvbiwgc28gaWYgdGhhdCdzXG4gICAgICAgIC8vIHlvdXIgY29uY2VybiwgZG9uJ3QgYWxsb3cgdGhlbS4gVGhlIHNhbWUgaXMgZXNzZW50aWFsbHkgdHJ1ZSBmb3Igc3R5bGUgdGFnc1xuICAgICAgICAvLyB3aGljaCBoYXZlIHRoZWlyIG93biBjb2xsZWN0aW9uIG9mIFhTUyB2ZWN0b3JzLlxuICAgICAgICByZXN1bHQgKz0gdGV4dDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGVzY2FwZWQgPSBlc2NhcGVIdG1sKHRleHQsIGZhbHNlKTtcbiAgICAgICAgaWYgKG9wdGlvbnMudGV4dEZpbHRlciAmJiAhYWRkZWRUZXh0KSB7XG4gICAgICAgICAgcmVzdWx0ICs9IG9wdGlvbnMudGV4dEZpbHRlcihlc2NhcGVkLCB0YWcpO1xuICAgICAgICB9IGVsc2UgaWYgKCFhZGRlZFRleHQpIHtcbiAgICAgICAgICByZXN1bHQgKz0gZXNjYXBlZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHN0YWNrLmxlbmd0aCkge1xuICAgICAgICBjb25zdCBmcmFtZSA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgICBmcmFtZS50ZXh0ICs9IHRleHQ7XG4gICAgICB9XG4gICAgfSxcbiAgICBvbmNsb3NldGFnOiBmdW5jdGlvbihuYW1lLCBpc0ltcGxpZWQpIHtcblxuICAgICAgaWYgKHNraXBUZXh0KSB7XG4gICAgICAgIHNraXBUZXh0RGVwdGgtLTtcbiAgICAgICAgaWYgKCFza2lwVGV4dERlcHRoKSB7XG4gICAgICAgICAgc2tpcFRleHQgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgZnJhbWUgPSBzdGFjay5wb3AoKTtcbiAgICAgIGlmICghZnJhbWUpIHtcbiAgICAgICAgLy8gRG8gbm90IGNyYXNoIG9uIGJhZCBtYXJrdXBcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoZnJhbWUudGFnICE9PSBuYW1lKSB7XG4gICAgICAgIC8vIEFub3RoZXIgY2FzZSBvZiBiYWQgbWFya3VwLlxuICAgICAgICAvLyBQdXNoIHRvIHN0YWNrLCBzbyB0aGF0IGl0IHdpbGwgYmUgdXNlZCBpbiBmdXR1cmUgY2xvc2luZyB0YWdzLlxuICAgICAgICBzdGFjay5wdXNoKGZyYW1lKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBza2lwVGV4dCA9IG9wdGlvbnMuZW5mb3JjZUh0bWxCb3VuZGFyeSA/IG5hbWUgPT09ICdodG1sJyA6IGZhbHNlO1xuICAgICAgZGVwdGgtLTtcbiAgICAgIGNvbnN0IHNraXAgPSBza2lwTWFwW2RlcHRoXTtcbiAgICAgIGlmIChza2lwKSB7XG4gICAgICAgIGRlbGV0ZSBza2lwTWFwW2RlcHRoXTtcbiAgICAgICAgaWYgKG9wdGlvbnMuZGlzYWxsb3dlZFRhZ3NNb2RlID09PSAnZGlzY2FyZCcpIHtcbiAgICAgICAgICBmcmFtZS51cGRhdGVQYXJlbnROb2RlVGV4dCgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0ZW1wUmVzdWx0ID0gcmVzdWx0O1xuICAgICAgICByZXN1bHQgPSAnJztcbiAgICAgIH1cblxuICAgICAgaWYgKHRyYW5zZm9ybU1hcFtkZXB0aF0pIHtcbiAgICAgICAgbmFtZSA9IHRyYW5zZm9ybU1hcFtkZXB0aF07XG4gICAgICAgIGRlbGV0ZSB0cmFuc2Zvcm1NYXBbZGVwdGhdO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5leGNsdXNpdmVGaWx0ZXIgJiYgb3B0aW9ucy5leGNsdXNpdmVGaWx0ZXIoZnJhbWUpKSB7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC5zdWJzdHIoMCwgZnJhbWUudGFnUG9zaXRpb24pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGZyYW1lLnVwZGF0ZVBhcmVudE5vZGVNZWRpYUNoaWxkcmVuKCk7XG4gICAgICBmcmFtZS51cGRhdGVQYXJlbnROb2RlVGV4dCgpO1xuXG4gICAgICBpZiAoXG4gICAgICAgIC8vIEFscmVhZHkgb3V0cHV0IC8+XG4gICAgICAgIG9wdGlvbnMuc2VsZkNsb3NpbmcuaW5kZXhPZihuYW1lKSAhPT0gLTEgfHxcbiAgICAgICAgLy8gRXNjYXBlZCB0YWcsIGNsb3NpbmcgdGFnIGlzIGltcGxpZWRcbiAgICAgICAgKGlzSW1wbGllZCAmJiAhdGFnQWxsb3dlZChuYW1lKSAmJiBbICdlc2NhcGUnLCAncmVjdXJzaXZlRXNjYXBlJyBdLmluZGV4T2Yob3B0aW9ucy5kaXNhbGxvd2VkVGFnc01vZGUpID49IDApXG4gICAgICApIHtcbiAgICAgICAgaWYgKHNraXApIHtcbiAgICAgICAgICByZXN1bHQgPSB0ZW1wUmVzdWx0O1xuICAgICAgICAgIHRlbXBSZXN1bHQgPSAnJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHJlc3VsdCArPSAnPC8nICsgbmFtZSArICc+JztcbiAgICAgIGlmIChza2lwKSB7XG4gICAgICAgIHJlc3VsdCA9IHRlbXBSZXN1bHQgKyBlc2NhcGVIdG1sKHJlc3VsdCk7XG4gICAgICAgIHRlbXBSZXN1bHQgPSAnJztcbiAgICAgIH1cbiAgICAgIGFkZGVkVGV4dCA9IGZhbHNlO1xuICAgIH1cbiAgfSwgb3B0aW9ucy5wYXJzZXIpO1xuICBwYXJzZXIud3JpdGUoaHRtbCk7XG4gIHBhcnNlci5lbmQoKTtcblxuICByZXR1cm4gcmVzdWx0O1xuXG4gIGZ1bmN0aW9uIGluaXRpYWxpemVTdGF0ZSgpIHtcbiAgICByZXN1bHQgPSAnJztcbiAgICBkZXB0aCA9IDA7XG4gICAgc3RhY2sgPSBbXTtcbiAgICBza2lwTWFwID0ge307XG4gICAgdHJhbnNmb3JtTWFwID0ge307XG4gICAgc2tpcFRleHQgPSBmYWxzZTtcbiAgICBza2lwVGV4dERlcHRoID0gMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGVzY2FwZUh0bWwocywgcXVvdGUpIHtcbiAgICBpZiAodHlwZW9mIChzKSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHMgPSBzICsgJyc7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnBhcnNlci5kZWNvZGVFbnRpdGllcykge1xuICAgICAgcyA9IHMucmVwbGFjZSgvJi9nLCAnJmFtcDsnKS5yZXBsYWNlKC88L2csICcmbHQ7JykucmVwbGFjZSgvPi9nLCAnJmd0OycpO1xuICAgICAgaWYgKHF1b3RlKSB7XG4gICAgICAgIHMgPSBzLnJlcGxhY2UoL1wiL2csICcmcXVvdDsnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gVE9ETzogdGhpcyBpcyBpbmFkZXF1YXRlIGJlY2F1c2UgaXQgd2lsbCBwYXNzIGAmMDtgLiBUaGlzIGFwcHJvYWNoXG4gICAgLy8gd2lsbCBub3Qgd29yaywgZWFjaCAmIG11c3QgYmUgY29uc2lkZXJlZCB3aXRoIHJlZ2FyZCB0byB3aGV0aGVyIGl0XG4gICAgLy8gaXMgZm9sbG93ZWQgYnkgYSAxMDAlIHN5bnRhY3RpY2FsbHkgdmFsaWQgZW50aXR5IG9yIG5vdCwgYW5kIGVzY2FwZWRcbiAgICAvLyBpZiBpdCBpcyBub3QuIElmIHRoaXMgYm90aGVycyB5b3UsIGRvbid0IHNldCBwYXJzZXIuZGVjb2RlRW50aXRpZXNcbiAgICAvLyB0byBmYWxzZS4gKFRoZSBkZWZhdWx0IGlzIHRydWUuKVxuICAgIHMgPSBzLnJlcGxhY2UoLyYoPyFbYS16QS1aMC05I117MSwyMH07KS9nLCAnJmFtcDsnKSAvLyBNYXRjaCBhbXBlcnNhbmRzIG5vdCBwYXJ0IG9mIGV4aXN0aW5nIEhUTUwgZW50aXR5XG4gICAgICAucmVwbGFjZSgvPC9nLCAnJmx0OycpXG4gICAgICAucmVwbGFjZSgvPi9nLCAnJmd0OycpO1xuICAgIGlmIChxdW90ZSkge1xuICAgICAgcyA9IHMucmVwbGFjZSgvXCIvZywgJyZxdW90OycpO1xuICAgIH1cbiAgICByZXR1cm4gcztcbiAgfVxuXG4gIGZ1bmN0aW9uIG5hdWdodHlIcmVmKG5hbWUsIGhyZWYpIHtcbiAgICAvLyBCcm93c2VycyBpZ25vcmUgY2hhcmFjdGVyIGNvZGVzIG9mIDMyIChzcGFjZSkgYW5kIGJlbG93IGluIGEgc3VycHJpc2luZ1xuICAgIC8vIG51bWJlciBvZiBzaXR1YXRpb25zLiBTdGFydCByZWFkaW5nIGhlcmU6XG4gICAgLy8gaHR0cHM6Ly93d3cub3dhc3Aub3JnL2luZGV4LnBocC9YU1NfRmlsdGVyX0V2YXNpb25fQ2hlYXRfU2hlZXQjRW1iZWRkZWRfdGFiXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnRyb2wtcmVnZXhcbiAgICBocmVmID0gaHJlZi5yZXBsYWNlKC9bXFx4MDAtXFx4MjBdKy9nLCAnJyk7XG4gICAgLy8gQ2xvYmJlciBhbnkgY29tbWVudHMgaW4gVVJMcywgd2hpY2ggdGhlIGJyb3dzZXIgbWlnaHRcbiAgICAvLyBpbnRlcnByZXQgaW5zaWRlIGFuIFhNTCBkYXRhIGlzbGFuZCwgYWxsb3dpbmdcbiAgICAvLyBhIGphdmFzY3JpcHQ6IFVSTCB0byBiZSBzbnVjayB0aHJvdWdoXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGNvbnN0IGZpcnN0SW5kZXggPSBocmVmLmluZGV4T2YoJzwhLS0nKTtcbiAgICAgIGlmIChmaXJzdEluZGV4ID09PSAtMSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNvbnN0IGxhc3RJbmRleCA9IGhyZWYuaW5kZXhPZignLS0+JywgZmlyc3RJbmRleCArIDQpO1xuICAgICAgaWYgKGxhc3RJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBocmVmID0gaHJlZi5zdWJzdHJpbmcoMCwgZmlyc3RJbmRleCkgKyBocmVmLnN1YnN0cmluZyhsYXN0SW5kZXggKyAzKTtcbiAgICB9XG4gICAgLy8gQ2FzZSBpbnNlbnNpdGl2ZSBzbyB3ZSBkb24ndCBnZXQgZmFrZWQgb3V0IGJ5IEpBVkFTQ1JJUFQgIzFcbiAgICAvLyBBbGxvdyBtb3JlIGNoYXJhY3RlcnMgYWZ0ZXIgdGhlIGZpcnN0IHNvIHdlIGRvbid0IGdldCBmYWtlZFxuICAgIC8vIG91dCBieSBjZXJ0YWluIHNjaGVtZXMgYnJvd3NlcnMgYWNjZXB0XG4gICAgY29uc3QgbWF0Y2hlcyA9IGhyZWYubWF0Y2goL14oW2EtekEtWl1bYS16QS1aMC05LlxcLStdKik6Lyk7XG4gICAgaWYgKCFtYXRjaGVzKSB7XG4gICAgICAvLyBQcm90b2NvbC1yZWxhdGl2ZSBVUkwgc3RhcnRpbmcgd2l0aCBhbnkgY29tYmluYXRpb24gb2YgJy8nIGFuZCAnXFwnXG4gICAgICBpZiAoaHJlZi5tYXRjaCgvXlsvXFxcXF17Mn0vKSkge1xuICAgICAgICByZXR1cm4gIW9wdGlvbnMuYWxsb3dQcm90b2NvbFJlbGF0aXZlO1xuICAgICAgfVxuXG4gICAgICAvLyBObyBzY2hlbWVcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3Qgc2NoZW1lID0gbWF0Y2hlc1sxXS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgaWYgKGhhcyhvcHRpb25zLmFsbG93ZWRTY2hlbWVzQnlUYWcsIG5hbWUpKSB7XG4gICAgICByZXR1cm4gb3B0aW9ucy5hbGxvd2VkU2NoZW1lc0J5VGFnW25hbWVdLmluZGV4T2Yoc2NoZW1lKSA9PT0gLTE7XG4gICAgfVxuXG4gICAgcmV0dXJuICFvcHRpb25zLmFsbG93ZWRTY2hlbWVzIHx8IG9wdGlvbnMuYWxsb3dlZFNjaGVtZXMuaW5kZXhPZihzY2hlbWUpID09PSAtMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlVXJsKHZhbHVlKSB7XG4gICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9eKFxcdys6KT9cXHMqW1xcXFwvXVxccypbXFxcXC9dLywgJyQxLy8nKTtcbiAgICBpZiAodmFsdWUuc3RhcnRzV2l0aCgncmVsYXRpdmU6JykpIHtcbiAgICAgIC8vIEFuIGF0dGVtcHQgdG8gZXhwbG9pdCBvdXIgd29ya2Fyb3VuZCBmb3IgYmFzZSBVUkxzIGJlaW5nXG4gICAgICAvLyBtYW5kYXRvcnkgZm9yIHJlbGF0aXZlIFVSTCB2YWxpZGF0aW9uIGluIHRoZSBXSEFUV0dcbiAgICAgIC8vIFVSTCBwYXJzZXIsIHJlamVjdCBpdFxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZWxhdGl2ZTogZXhwbG9pdCBhdHRlbXB0Jyk7XG4gICAgfVxuICAgIC8vIG5hdWdodHlIcmVmIGlzIGluIGNoYXJnZSBvZiB3aGV0aGVyIHByb3RvY29sIHJlbGF0aXZlIFVSTHNcbiAgICAvLyBhcmUgY29vbC4gSGVyZSB3ZSBhcmUgY29uY2VybmVkIGp1c3Qgd2l0aCBhbGxvd2VkIGhvc3RuYW1lcyBhbmRcbiAgICAvLyB3aGV0aGVyIHRvIGFsbG93IHJlbGF0aXZlIFVSTHMuXG4gICAgLy9cbiAgICAvLyBCdWlsZCBhIHBsYWNlaG9sZGVyIFwiYmFzZSBVUkxcIiBhZ2FpbnN0IHdoaWNoIGFueSByZWFzb25hYmxlXG4gICAgLy8gcmVsYXRpdmUgVVJMIG1heSBiZSBwYXJzZWQgc3VjY2Vzc2Z1bGx5XG4gICAgbGV0IGJhc2UgPSAncmVsYXRpdmU6Ly9yZWxhdGl2ZS1zaXRlJztcbiAgICBmb3IgKGxldCBpID0gMDsgKGkgPCAxMDApOyBpKyspIHtcbiAgICAgIGJhc2UgKz0gYC8ke2l9YDtcbiAgICB9XG5cbiAgICBjb25zdCBwYXJzZWQgPSBuZXcgVVJMKHZhbHVlLCBiYXNlKTtcblxuICAgIGNvbnN0IGlzUmVsYXRpdmVVcmwgPSBwYXJzZWQgJiYgcGFyc2VkLmhvc3RuYW1lID09PSAncmVsYXRpdmUtc2l0ZScgJiYgcGFyc2VkLnByb3RvY29sID09PSAncmVsYXRpdmU6JztcbiAgICByZXR1cm4ge1xuICAgICAgaXNSZWxhdGl2ZVVybCxcbiAgICAgIHVybDogcGFyc2VkXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogRmlsdGVycyB1c2VyIGlucHV0IGNzcyBwcm9wZXJ0aWVzIGJ5IGFsbG93bGlzdGVkIHJlZ2V4IGF0dHJpYnV0ZXMuXG4gICAqIE1vZGlmaWVzIHRoZSBhYnN0cmFjdFN5bnRheFRyZWUgb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gYWJzdHJhY3RTeW50YXhUcmVlICAtIE9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBDU1MgYXR0cmlidXRlcy5cbiAgICogQHByb3BlcnR5IHthcnJheVtEZWNsYXJhdGlvbl19IGFic3RyYWN0U3ludGF4VHJlZS5ub2Rlc1swXSAtIEVhY2ggb2JqZWN0IGNvaW50YWlucyBwcm9wIGFuZCB2YWx1ZSBrZXksIGkuZSB7IHByb3A6ICdjb2xvcicsIHZhbHVlOiAncmVkJyB9LlxuICAgKiBAcGFyYW0ge29iamVjdH0gYWxsb3dlZFN0eWxlcyAgICAgICAtIEtleXMgYXJlIHByb3BlcnRpZXMgKGkuZSBjb2xvciksIHZhbHVlIGlzIGxpc3Qgb2YgcGVybWl0dGVkIHJlZ2V4IHJ1bGVzIChpLmUgL2dyZWVuL2kpLlxuICAgKiBAcmV0dXJuIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgICAtIFRoZSBtb2RpZmllZCB0cmVlLlxuICAgKi9cbiAgZnVuY3Rpb24gZmlsdGVyQ3NzKGFic3RyYWN0U3ludGF4VHJlZSwgYWxsb3dlZFN0eWxlcykge1xuICAgIGlmICghYWxsb3dlZFN0eWxlcykge1xuICAgICAgcmV0dXJuIGFic3RyYWN0U3ludGF4VHJlZTtcbiAgICB9XG5cbiAgICBjb25zdCBhc3RSdWxlcyA9IGFic3RyYWN0U3ludGF4VHJlZS5ub2Rlc1swXTtcbiAgICBsZXQgc2VsZWN0ZWRSdWxlO1xuXG4gICAgLy8gTWVyZ2UgZ2xvYmFsIGFuZCB0YWctc3BlY2lmaWMgc3R5bGVzIGludG8gbmV3IEFTVC5cbiAgICBpZiAoYWxsb3dlZFN0eWxlc1thc3RSdWxlcy5zZWxlY3Rvcl0gJiYgYWxsb3dlZFN0eWxlc1snKiddKSB7XG4gICAgICBzZWxlY3RlZFJ1bGUgPSBkZWVwbWVyZ2UoXG4gICAgICAgIGFsbG93ZWRTdHlsZXNbYXN0UnVsZXMuc2VsZWN0b3JdLFxuICAgICAgICBhbGxvd2VkU3R5bGVzWycqJ11cbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlbGVjdGVkUnVsZSA9IGFsbG93ZWRTdHlsZXNbYXN0UnVsZXMuc2VsZWN0b3JdIHx8IGFsbG93ZWRTdHlsZXNbJyonXTtcbiAgICB9XG5cbiAgICBpZiAoc2VsZWN0ZWRSdWxlKSB7XG4gICAgICBhYnN0cmFjdFN5bnRheFRyZWUubm9kZXNbMF0ubm9kZXMgPSBhc3RSdWxlcy5ub2Rlcy5yZWR1Y2UoZmlsdGVyRGVjbGFyYXRpb25zKHNlbGVjdGVkUnVsZSksIFtdKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYWJzdHJhY3RTeW50YXhUcmVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4dHJhY3RzIHRoZSBzdHlsZSBhdHRyaWJ1dGVzIGZyb20gYW4gQWJzdHJhY3RTeW50YXhUcmVlIGFuZCBmb3JtYXRzIHRob3NlXG4gICAqIHZhbHVlcyBpbiB0aGUgaW5saW5lIHN0eWxlIGF0dHJpYnV0ZSBmb3JtYXQuXG4gICAqXG4gICAqIEBwYXJhbSAge0Fic3RyYWN0U3ludGF4VHJlZX0gZmlsdGVyZWRBU1RcbiAgICogQHJldHVybiB7c3RyaW5nfSAgICAgICAgICAgICAtIEV4YW1wbGU6IFwiY29sb3I6eWVsbG93O3RleHQtYWxpZ246Y2VudGVyICFpbXBvcnRhbnQ7Zm9udC1mYW1pbHk6aGVsdmV0aWNhO1wiXG4gICAqL1xuICBmdW5jdGlvbiBzdHJpbmdpZnlTdHlsZUF0dHJpYnV0ZXMoZmlsdGVyZWRBU1QpIHtcbiAgICByZXR1cm4gZmlsdGVyZWRBU1Qubm9kZXNbMF0ubm9kZXNcbiAgICAgIC5yZWR1Y2UoZnVuY3Rpb24oZXh0cmFjdGVkQXR0cmlidXRlcywgYXR0ck9iamVjdCkge1xuICAgICAgICBleHRyYWN0ZWRBdHRyaWJ1dGVzLnB1c2goXG4gICAgICAgICAgYCR7YXR0ck9iamVjdC5wcm9wfToke2F0dHJPYmplY3QudmFsdWV9JHthdHRyT2JqZWN0LmltcG9ydGFudCA/ICcgIWltcG9ydGFudCcgOiAnJ31gXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBleHRyYWN0ZWRBdHRyaWJ1dGVzO1xuICAgICAgfSwgW10pXG4gICAgICAuam9pbignOycpO1xuICB9XG5cbiAgLyoqXG4gICAgKiBGaWx0ZXJzIHRoZSBleGlzdGluZyBhdHRyaWJ1dGVzIGZvciB0aGUgZ2l2ZW4gcHJvcGVydHkuIERpc2NhcmRzIGFueSBhdHRyaWJ1dGVzXG4gICAgKiB3aGljaCBkb24ndCBtYXRjaCB0aGUgYWxsb3dsaXN0LlxuICAgICpcbiAgICAqIEBwYXJhbSAge29iamVjdH0gc2VsZWN0ZWRSdWxlICAgICAgICAgICAgIC0gRXhhbXBsZTogeyBjb2xvcjogcmVkLCBmb250LWZhbWlseTogaGVsdmV0aWNhIH1cbiAgICAqIEBwYXJhbSAge2FycmF5fSBhbGxvd2VkRGVjbGFyYXRpb25zTGlzdCAgIC0gTGlzdCBvZiBkZWNsYXJhdGlvbnMgd2hpY2ggcGFzcyB0aGUgYWxsb3dsaXN0LlxuICAgICogQHBhcmFtICB7b2JqZWN0fSBhdHRyaWJ1dGVPYmplY3QgICAgICAgICAgLSBPYmplY3QgcmVwcmVzZW50aW5nIHRoZSBjdXJyZW50IGNzcyBwcm9wZXJ0eS5cbiAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBhdHRyaWJ1dGVPYmplY3QudHlwZSAgIC0gVHlwaWNhbGx5ICdkZWNsYXJhdGlvbicuXG4gICAgKiBAcHJvcGVydHkge3N0cmluZ30gYXR0cmlidXRlT2JqZWN0LnByb3AgICAtIFRoZSBDU1MgcHJvcGVydHksIGkuZSAnY29sb3InLlxuICAgICogQHByb3BlcnR5IHtzdHJpbmd9IGF0dHJpYnV0ZU9iamVjdC52YWx1ZSAgLSBUaGUgY29ycmVzcG9uZGluZyB2YWx1ZSB0byB0aGUgY3NzIHByb3BlcnR5LCBpLmUgJ3JlZCcuXG4gICAgKiBAcmV0dXJuIHtmdW5jdGlvbn0gICAgICAgICAgICAgICAgICAgICAgICAtIFdoZW4gdXNlZCBpbiBBcnJheS5yZWR1Y2UsIHdpbGwgcmV0dXJuIGFuIGFycmF5IG9mIERlY2xhcmF0aW9uIG9iamVjdHNcbiAgICAqL1xuICBmdW5jdGlvbiBmaWx0ZXJEZWNsYXJhdGlvbnMoc2VsZWN0ZWRSdWxlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChhbGxvd2VkRGVjbGFyYXRpb25zTGlzdCwgYXR0cmlidXRlT2JqZWN0KSB7XG4gICAgICAvLyBJZiB0aGlzIHByb3BlcnR5IGlzIGFsbG93bGlzdGVkLi4uXG4gICAgICBpZiAoaGFzKHNlbGVjdGVkUnVsZSwgYXR0cmlidXRlT2JqZWN0LnByb3ApKSB7XG4gICAgICAgIGNvbnN0IG1hdGNoZXNSZWdleCA9IHNlbGVjdGVkUnVsZVthdHRyaWJ1dGVPYmplY3QucHJvcF0uc29tZShmdW5jdGlvbihyZWd1bGFyRXhwcmVzc2lvbikge1xuICAgICAgICAgIHJldHVybiByZWd1bGFyRXhwcmVzc2lvbi50ZXN0KGF0dHJpYnV0ZU9iamVjdC52YWx1ZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChtYXRjaGVzUmVnZXgpIHtcbiAgICAgICAgICBhbGxvd2VkRGVjbGFyYXRpb25zTGlzdC5wdXNoKGF0dHJpYnV0ZU9iamVjdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBhbGxvd2VkRGVjbGFyYXRpb25zTGlzdDtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gZmlsdGVyQ2xhc3NlcyhjbGFzc2VzLCBhbGxvd2VkLCBhbGxvd2VkR2xvYnMpIHtcbiAgICBpZiAoIWFsbG93ZWQpIHtcbiAgICAgIC8vIFRoZSBjbGFzcyBhdHRyaWJ1dGUgaXMgYWxsb3dlZCB3aXRob3V0IGZpbHRlcmluZyBvbiB0aGlzIHRhZ1xuICAgICAgcmV0dXJuIGNsYXNzZXM7XG4gICAgfVxuICAgIGNsYXNzZXMgPSBjbGFzc2VzLnNwbGl0KC9cXHMrLyk7XG4gICAgcmV0dXJuIGNsYXNzZXMuZmlsdGVyKGZ1bmN0aW9uKGNsc3MpIHtcbiAgICAgIHJldHVybiBhbGxvd2VkLmluZGV4T2YoY2xzcykgIT09IC0xIHx8IGFsbG93ZWRHbG9icy5zb21lKGZ1bmN0aW9uKGdsb2IpIHtcbiAgICAgICAgcmV0dXJuIGdsb2IudGVzdChjbHNzKTtcbiAgICAgIH0pO1xuICAgIH0pLmpvaW4oJyAnKTtcbiAgfVxufVxuXG4vLyBEZWZhdWx0cyBhcmUgYWNjZXNzaWJsZSB0byB5b3Ugc28gdGhhdCB5b3UgY2FuIHVzZSB0aGVtIGFzIGEgc3RhcnRpbmcgcG9pbnRcbi8vIHByb2dyYW1tYXRpY2FsbHkgaWYgeW91IHdpc2hcblxuY29uc3QgaHRtbFBhcnNlckRlZmF1bHRzID0ge1xuICBkZWNvZGVFbnRpdGllczogdHJ1ZVxufTtcbnNhbml0aXplSHRtbC5kZWZhdWx0cyA9IHtcbiAgYWxsb3dlZFRhZ3M6IFtcbiAgICAvLyBTZWN0aW9ucyBkZXJpdmVkIGZyb20gTUROIGVsZW1lbnQgY2F0ZWdvcmllcyBhbmQgbGltaXRlZCB0byB0aGUgbW9yZVxuICAgIC8vIGJlbmlnbiBjYXRlZ29yaWVzLlxuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvRWxlbWVudFxuICAgIC8vIENvbnRlbnQgc2VjdGlvbmluZ1xuICAgICdhZGRyZXNzJywgJ2FydGljbGUnLCAnYXNpZGUnLCAnZm9vdGVyJywgJ2hlYWRlcicsXG4gICAgJ2gxJywgJ2gyJywgJ2gzJywgJ2g0JywgJ2g1JywgJ2g2JywgJ2hncm91cCcsXG4gICAgJ21haW4nLCAnbmF2JywgJ3NlY3Rpb24nLFxuICAgIC8vIFRleHQgY29udGVudFxuICAgICdibG9ja3F1b3RlJywgJ2RkJywgJ2RpdicsICdkbCcsICdkdCcsICdmaWdjYXB0aW9uJywgJ2ZpZ3VyZScsXG4gICAgJ2hyJywgJ2xpJywgJ21haW4nLCAnb2wnLCAncCcsICdwcmUnLCAndWwnLFxuICAgIC8vIElubGluZSB0ZXh0IHNlbWFudGljc1xuICAgICdhJywgJ2FiYnInLCAnYicsICdiZGknLCAnYmRvJywgJ2JyJywgJ2NpdGUnLCAnY29kZScsICdkYXRhJywgJ2RmbicsXG4gICAgJ2VtJywgJ2knLCAna2JkJywgJ21hcmsnLCAncScsXG4gICAgJ3JiJywgJ3JwJywgJ3J0JywgJ3J0YycsICdydWJ5JyxcbiAgICAncycsICdzYW1wJywgJ3NtYWxsJywgJ3NwYW4nLCAnc3Ryb25nJywgJ3N1YicsICdzdXAnLCAndGltZScsICd1JywgJ3ZhcicsICd3YnInLFxuICAgIC8vIFRhYmxlIGNvbnRlbnRcbiAgICAnY2FwdGlvbicsICdjb2wnLCAnY29sZ3JvdXAnLCAndGFibGUnLCAndGJvZHknLCAndGQnLCAndGZvb3QnLCAndGgnLFxuICAgICd0aGVhZCcsICd0cidcbiAgXSxcbiAgLy8gVGFncyB0aGF0IGNhbm5vdCBiZSBib29sZWFuXG4gIG5vbkJvb2xlYW5BdHRyaWJ1dGVzOiBbXG4gICAgJ2FiYnInLCAnYWNjZXB0JywgJ2FjY2VwdC1jaGFyc2V0JywgJ2FjY2Vzc2tleScsICdhY3Rpb24nLFxuICAgICdhbGxvdycsICdhbHQnLCAnYXMnLCAnYXV0b2NhcGl0YWxpemUnLCAnYXV0b2NvbXBsZXRlJyxcbiAgICAnYmxvY2tpbmcnLCAnY2hhcnNldCcsICdjaXRlJywgJ2NsYXNzJywgJ2NvbG9yJywgJ2NvbHMnLFxuICAgICdjb2xzcGFuJywgJ2NvbnRlbnQnLCAnY29udGVudGVkaXRhYmxlJywgJ2Nvb3JkcycsICdjcm9zc29yaWdpbicsXG4gICAgJ2RhdGEnLCAnZGF0ZXRpbWUnLCAnZGVjb2RpbmcnLCAnZGlyJywgJ2Rpcm5hbWUnLCAnZG93bmxvYWQnLFxuICAgICdkcmFnZ2FibGUnLCAnZW5jdHlwZScsICdlbnRlcmtleWhpbnQnLCAnZmV0Y2hwcmlvcml0eScsICdmb3InLFxuICAgICdmb3JtJywgJ2Zvcm1hY3Rpb24nLCAnZm9ybWVuY3R5cGUnLCAnZm9ybW1ldGhvZCcsICdmb3JtdGFyZ2V0JyxcbiAgICAnaGVhZGVycycsICdoZWlnaHQnLCAnaGlkZGVuJywgJ2hpZ2gnLCAnaHJlZicsICdocmVmbGFuZycsXG4gICAgJ2h0dHAtZXF1aXYnLCAnaWQnLCAnaW1hZ2VzaXplcycsICdpbWFnZXNyY3NldCcsICdpbnB1dG1vZGUnLFxuICAgICdpbnRlZ3JpdHknLCAnaXMnLCAnaXRlbWlkJywgJ2l0ZW1wcm9wJywgJ2l0ZW1yZWYnLCAnaXRlbXR5cGUnLFxuICAgICdraW5kJywgJ2xhYmVsJywgJ2xhbmcnLCAnbGlzdCcsICdsb2FkaW5nJywgJ2xvdycsICdtYXgnLFxuICAgICdtYXhsZW5ndGgnLCAnbWVkaWEnLCAnbWV0aG9kJywgJ21pbicsICdtaW5sZW5ndGgnLCAnbmFtZScsXG4gICAgJ25vbmNlJywgJ29wdGltdW0nLCAncGF0dGVybicsICdwaW5nJywgJ3BsYWNlaG9sZGVyJywgJ3BvcG92ZXInLFxuICAgICdwb3BvdmVydGFyZ2V0JywgJ3BvcG92ZXJ0YXJnZXRhY3Rpb24nLCAncG9zdGVyJywgJ3ByZWxvYWQnLFxuICAgICdyZWZlcnJlcnBvbGljeScsICdyZWwnLCAncm93cycsICdyb3dzcGFuJywgJ3NhbmRib3gnLCAnc2NvcGUnLFxuICAgICdzaGFwZScsICdzaXplJywgJ3NpemVzJywgJ3Nsb3QnLCAnc3BhbicsICdzcGVsbGNoZWNrJywgJ3NyYycsXG4gICAgJ3NyY2RvYycsICdzcmNsYW5nJywgJ3NyY3NldCcsICdzdGFydCcsICdzdGVwJywgJ3N0eWxlJyxcbiAgICAndGFiaW5kZXgnLCAndGFyZ2V0JywgJ3RpdGxlJywgJ3RyYW5zbGF0ZScsICd0eXBlJywgJ3VzZW1hcCcsXG4gICAgJ3ZhbHVlJywgJ3dpZHRoJywgJ3dyYXAnLFxuICAgIC8vIEV2ZW50IGhhbmRsZXJzXG4gICAgJ29uYXV4Y2xpY2snLCAnb25hZnRlcnByaW50JywgJ29uYmVmb3JlbWF0Y2gnLCAnb25iZWZvcmVwcmludCcsXG4gICAgJ29uYmVmb3JldW5sb2FkJywgJ29uYmVmb3JldG9nZ2xlJywgJ29uYmx1cicsICdvbmNhbmNlbCcsXG4gICAgJ29uY2FucGxheScsICdvbmNhbnBsYXl0aHJvdWdoJywgJ29uY2hhbmdlJywgJ29uY2xpY2snLCAnb25jbG9zZScsXG4gICAgJ29uY29udGV4dGxvc3QnLCAnb25jb250ZXh0bWVudScsICdvbmNvbnRleHRyZXN0b3JlZCcsICdvbmNvcHknLFxuICAgICdvbmN1ZWNoYW5nZScsICdvbmN1dCcsICdvbmRibGNsaWNrJywgJ29uZHJhZycsICdvbmRyYWdlbmQnLFxuICAgICdvbmRyYWdlbnRlcicsICdvbmRyYWdsZWF2ZScsICdvbmRyYWdvdmVyJywgJ29uZHJhZ3N0YXJ0JyxcbiAgICAnb25kcm9wJywgJ29uZHVyYXRpb25jaGFuZ2UnLCAnb25lbXB0aWVkJywgJ29uZW5kZWQnLFxuICAgICdvbmVycm9yJywgJ29uZm9jdXMnLCAnb25mb3JtZGF0YScsICdvbmhhc2hjaGFuZ2UnLCAnb25pbnB1dCcsXG4gICAgJ29uaW52YWxpZCcsICdvbmtleWRvd24nLCAnb25rZXlwcmVzcycsICdvbmtleXVwJyxcbiAgICAnb25sYW5ndWFnZWNoYW5nZScsICdvbmxvYWQnLCAnb25sb2FkZWRkYXRhJywgJ29ubG9hZGVkbWV0YWRhdGEnLFxuICAgICdvbmxvYWRzdGFydCcsICdvbm1lc3NhZ2UnLCAnb25tZXNzYWdlZXJyb3InLCAnb25tb3VzZWRvd24nLFxuICAgICdvbm1vdXNlZW50ZXInLCAnb25tb3VzZWxlYXZlJywgJ29ubW91c2Vtb3ZlJywgJ29ubW91c2VvdXQnLFxuICAgICdvbm1vdXNlb3ZlcicsICdvbm1vdXNldXAnLCAnb25vZmZsaW5lJywgJ29ub25saW5lJywgJ29ucGFnZWhpZGUnLFxuICAgICdvbnBhZ2VzaG93JywgJ29ucGFzdGUnLCAnb25wYXVzZScsICdvbnBsYXknLCAnb25wbGF5aW5nJyxcbiAgICAnb25wb3BzdGF0ZScsICdvbnByb2dyZXNzJywgJ29ucmF0ZWNoYW5nZScsICdvbnJlc2V0JywgJ29ucmVzaXplJyxcbiAgICAnb25yZWplY3Rpb25oYW5kbGVkJywgJ29uc2Nyb2xsJywgJ29uc2Nyb2xsZW5kJyxcbiAgICAnb25zZWN1cml0eXBvbGljeXZpb2xhdGlvbicsICdvbnNlZWtlZCcsICdvbnNlZWtpbmcnLCAnb25zZWxlY3QnLFxuICAgICdvbnNsb3RjaGFuZ2UnLCAnb25zdGFsbGVkJywgJ29uc3RvcmFnZScsICdvbnN1Ym1pdCcsICdvbnN1c3BlbmQnLFxuICAgICdvbnRpbWV1cGRhdGUnLCAnb250b2dnbGUnLCAnb251bmhhbmRsZWRyZWplY3Rpb24nLCAnb251bmxvYWQnLFxuICAgICdvbnZvbHVtZWNoYW5nZScsICdvbndhaXRpbmcnLCAnb253aGVlbCdcbiAgXSxcbiAgZGlzYWxsb3dlZFRhZ3NNb2RlOiAnZGlzY2FyZCcsXG4gIGFsbG93ZWRBdHRyaWJ1dGVzOiB7XG4gICAgYTogWyAnaHJlZicsICduYW1lJywgJ3RhcmdldCcgXSxcbiAgICAvLyBXZSBkb24ndCBjdXJyZW50bHkgYWxsb3cgaW1nIGl0c2VsZiBieSBkZWZhdWx0LCBidXRcbiAgICAvLyB0aGVzZSBhdHRyaWJ1dGVzIHdvdWxkIG1ha2Ugc2Vuc2UgaWYgd2UgZGlkLlxuICAgIGltZzogWyAnc3JjJywgJ3NyY3NldCcsICdhbHQnLCAndGl0bGUnLCAnd2lkdGgnLCAnaGVpZ2h0JywgJ2xvYWRpbmcnIF1cbiAgfSxcbiAgLy8gTG90cyBvZiB0aGVzZSB3b24ndCBjb21lIHVwIGJ5IGRlZmF1bHQgYmVjYXVzZSB3ZSBkb24ndCBhbGxvdyB0aGVtXG4gIHNlbGZDbG9zaW5nOiBbICdpbWcnLCAnYnInLCAnaHInLCAnYXJlYScsICdiYXNlJywgJ2Jhc2Vmb250JywgJ2lucHV0JywgJ2xpbmsnLCAnbWV0YScgXSxcbiAgLy8gVVJMIHNjaGVtZXMgd2UgcGVybWl0XG4gIGFsbG93ZWRTY2hlbWVzOiBbICdodHRwJywgJ2h0dHBzJywgJ2Z0cCcsICdtYWlsdG8nLCAndGVsJyBdLFxuICBhbGxvd2VkU2NoZW1lc0J5VGFnOiB7fSxcbiAgYWxsb3dlZFNjaGVtZXNBcHBsaWVkVG9BdHRyaWJ1dGVzOiBbICdocmVmJywgJ3NyYycsICdjaXRlJyBdLFxuICBhbGxvd1Byb3RvY29sUmVsYXRpdmU6IHRydWUsXG4gIGVuZm9yY2VIdG1sQm91bmRhcnk6IGZhbHNlLFxuICBwYXJzZVN0eWxlQXR0cmlidXRlczogdHJ1ZVxufTtcblxuc2FuaXRpemVIdG1sLnNpbXBsZVRyYW5zZm9ybSA9IGZ1bmN0aW9uKG5ld1RhZ05hbWUsIG5ld0F0dHJpYnMsIG1lcmdlKSB7XG4gIG1lcmdlID0gKG1lcmdlID09PSB1bmRlZmluZWQpID8gdHJ1ZSA6IG1lcmdlO1xuICBuZXdBdHRyaWJzID0gbmV3QXR0cmlicyB8fCB7fTtcblxuICByZXR1cm4gZnVuY3Rpb24odGFnTmFtZSwgYXR0cmlicykge1xuICAgIGxldCBhdHRyaWI7XG4gICAgaWYgKG1lcmdlKSB7XG4gICAgICBmb3IgKGF0dHJpYiBpbiBuZXdBdHRyaWJzKSB7XG4gICAgICAgIGF0dHJpYnNbYXR0cmliXSA9IG5ld0F0dHJpYnNbYXR0cmliXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgYXR0cmlicyA9IG5ld0F0dHJpYnM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHRhZ05hbWU6IG5ld1RhZ05hbWUsXG4gICAgICBhdHRyaWJzOiBhdHRyaWJzXG4gICAgfTtcbiAgfTtcbn07XG4iXSwibmFtZXMiOlsiaHRtbHBhcnNlciIsInJlcXVpcmUiLCJlc2NhcGVTdHJpbmdSZWdleHAiLCJpc1BsYWluT2JqZWN0IiwiZGVlcG1lcmdlIiwicGFyc2VTcmNzZXQiLCJwYXJzZSIsInBvc3Rjc3NQYXJzZSIsIm1lZGlhVGFncyIsInZ1bG5lcmFibGVUYWdzIiwiZWFjaCIsIm9iaiIsImNiIiwiT2JqZWN0Iiwia2V5cyIsImZvckVhY2giLCJrZXkiLCJoYXMiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJmaWx0ZXIiLCJhIiwibiIsInYiLCJwdXNoIiwiaXNFbXB0eU9iamVjdCIsInN0cmluZ2lmeVNyY3NldCIsInBhcnNlZFNyY3NldCIsIm1hcCIsInBhcnQiLCJ1cmwiLCJFcnJvciIsInciLCJoIiwiZCIsImpvaW4iLCJtb2R1bGUiLCJleHBvcnRzIiwic2FuaXRpemVIdG1sIiwiVkFMSURfSFRNTF9BVFRSSUJVVEVfTkFNRSIsImh0bWwiLCJvcHRpb25zIiwiX3JlY3Vyc2luZyIsInRvU3RyaW5nIiwicmVzdWx0IiwidGVtcFJlc3VsdCIsIkZyYW1lIiwidGFnIiwiYXR0cmlicyIsInRoYXQiLCJ0YWdQb3NpdGlvbiIsImxlbmd0aCIsInRleHQiLCJtZWRpYUNoaWxkcmVuIiwidXBkYXRlUGFyZW50Tm9kZVRleHQiLCJzdGFjayIsInBhcmVudEZyYW1lIiwidXBkYXRlUGFyZW50Tm9kZU1lZGlhQ2hpbGRyZW4iLCJpbmNsdWRlcyIsImFzc2lnbiIsImRlZmF1bHRzIiwicGFyc2VyIiwiaHRtbFBhcnNlckRlZmF1bHRzIiwidGFnQWxsb3dlZCIsIm5hbWUiLCJhbGxvd2VkVGFncyIsImluZGV4T2YiLCJhbGxvd1Z1bG5lcmFibGVUYWdzIiwiY29uc29sZSIsIndhcm4iLCJub25UZXh0VGFnc0FycmF5Iiwibm9uVGV4dFRhZ3MiLCJhbGxvd2VkQXR0cmlidXRlc01hcCIsImFsbG93ZWRBdHRyaWJ1dGVzR2xvYk1hcCIsImFsbG93ZWRBdHRyaWJ1dGVzIiwiYXR0cmlidXRlcyIsImdsb2JSZWdleCIsInJlcGxhY2UiLCJSZWdFeHAiLCJhbGxvd2VkQ2xhc3Nlc01hcCIsImFsbG93ZWRDbGFzc2VzR2xvYk1hcCIsImFsbG93ZWRDbGFzc2VzUmVnZXhNYXAiLCJhbGxvd2VkQ2xhc3NlcyIsImNsYXNzZXMiLCJBcnJheSIsImlzQXJyYXkiLCJ0cmFuc2Zvcm1UYWdzTWFwIiwidHJhbnNmb3JtVGFnc0FsbCIsInRyYW5zZm9ybVRhZ3MiLCJ0cmFuc2Zvcm0iLCJ0cmFuc0Z1biIsInNpbXBsZVRyYW5zZm9ybSIsImRlcHRoIiwic2tpcE1hcCIsInRyYW5zZm9ybU1hcCIsInNraXBUZXh0Iiwic2tpcFRleHREZXB0aCIsImFkZGVkVGV4dCIsImluaXRpYWxpemVTdGF0ZSIsIlBhcnNlciIsIm9ub3BlbnRhZyIsImVuZm9yY2VIdG1sQm91bmRhcnkiLCJmcmFtZSIsInNraXAiLCJoYXNUZXh0IiwidHJhbnNmb3JtZWRUYWciLCJ1bmRlZmluZWQiLCJpbm5lclRleHQiLCJ0YWdOYW1lIiwiZGlzYWxsb3dlZFRhZ3NNb2RlIiwibmVzdGluZ0xpbWl0IiwiYWxsb3dlZFNjcmlwdEhvc3RuYW1lcyIsImFsbG93ZWRTY3JpcHREb21haW5zIiwidmFsdWUiLCJ0ZXN0Iiwibm9uQm9vbGVhbkF0dHJpYnV0ZXMiLCJwYXNzZWRBbGxvd2VkQXR0cmlidXRlc01hcENoZWNrIiwibyIsIm5ld1ZhbHVlIiwibXVsdGlwbGUiLCJzcGxpdFN0ckFycmF5Iiwic3BsaXQiLCJzIiwidmFsdWVzIiwiYWxsb3dlZFNjaGVtZXNBcHBsaWVkVG9BdHRyaWJ1dGVzIiwibmF1Z2h0eUhyZWYiLCJhbGxvd2VkIiwicGFyc2VkIiwicGFyc2VVcmwiLCJhbGxvd2VkSG9zdG5hbWUiLCJmaW5kIiwiaG9zdG5hbWUiLCJhbGxvd2VkRG9tYWluIiwiZG9tYWluIiwiZW5kc1dpdGgiLCJlIiwiaXNSZWxhdGl2ZVVybCIsImFsbG93SWZyYW1lUmVsYXRpdmVVcmxzIiwiYWxsb3dlZElmcmFtZUhvc3RuYW1lcyIsImFsbG93ZWRJZnJhbWVEb21haW5zIiwiZXZpbCIsImFsbG93ZWRTcGVjaWZpY0NsYXNzZXMiLCJhbGxvd2VkV2lsZGNhcmRDbGFzc2VzIiwiYWxsb3dlZFNwZWNpZmljQ2xhc3Nlc0dsb2IiLCJhbGxvd2VkU3BlY2lmaWNDbGFzc2VzUmVnZXgiLCJhbGxvd2VkV2lsZGNhcmRDbGFzc2VzR2xvYiIsImFsbG93ZWRDbGFzc2VzR2xvYnMiLCJjb25jYXQiLCJ0IiwiZmlsdGVyQ2xhc3NlcyIsInBhcnNlU3R5bGVBdHRyaWJ1dGVzIiwiYWJzdHJhY3RTeW50YXhUcmVlIiwiZmlsdGVyZWRBU1QiLCJmaWx0ZXJDc3MiLCJhbGxvd2VkU3R5bGVzIiwic3RyaW5naWZ5U3R5bGVBdHRyaWJ1dGVzIiwiZXNjYXBlSHRtbCIsInNlbGZDbG9zaW5nIiwidGV4dEZpbHRlciIsIm9udGV4dCIsImxhc3RGcmFtZSIsImVzY2FwZWQiLCJvbmNsb3NldGFnIiwiaXNJbXBsaWVkIiwicG9wIiwiZXhjbHVzaXZlRmlsdGVyIiwic3Vic3RyIiwid3JpdGUiLCJlbmQiLCJxdW90ZSIsImRlY29kZUVudGl0aWVzIiwiaHJlZiIsImZpcnN0SW5kZXgiLCJsYXN0SW5kZXgiLCJzdWJzdHJpbmciLCJtYXRjaGVzIiwibWF0Y2giLCJhbGxvd1Byb3RvY29sUmVsYXRpdmUiLCJzY2hlbWUiLCJ0b0xvd2VyQ2FzZSIsImFsbG93ZWRTY2hlbWVzQnlUYWciLCJhbGxvd2VkU2NoZW1lcyIsInN0YXJ0c1dpdGgiLCJiYXNlIiwiaSIsIlVSTCIsInByb3RvY29sIiwiYXN0UnVsZXMiLCJub2RlcyIsInNlbGVjdGVkUnVsZSIsInNlbGVjdG9yIiwicmVkdWNlIiwiZmlsdGVyRGVjbGFyYXRpb25zIiwiZXh0cmFjdGVkQXR0cmlidXRlcyIsImF0dHJPYmplY3QiLCJwcm9wIiwiaW1wb3J0YW50IiwiYWxsb3dlZERlY2xhcmF0aW9uc0xpc3QiLCJhdHRyaWJ1dGVPYmplY3QiLCJtYXRjaGVzUmVnZXgiLCJzb21lIiwicmVndWxhckV4cHJlc3Npb24iLCJhbGxvd2VkR2xvYnMiLCJjbHNzIiwiZ2xvYiIsImltZyIsIm5ld1RhZ05hbWUiLCJuZXdBdHRyaWJzIiwibWVyZ2UiLCJhdHRyaWIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/sanitize-html/index.js\n");

/***/ })

};
;