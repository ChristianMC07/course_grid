"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/parse-srcset";
exports.ids = ["vendor-chunks/parse-srcset"];
exports.modules = {

/***/ "(action-browser)/./node_modules/parse-srcset/src/parse-srcset.js":
/*!*******************************************************!*\
  !*** ./node_modules/parse-srcset/src/parse-srcset.js ***!
  \*******************************************************/
/***/ ((module, exports) => {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n/**\n * Srcset Parser\n *\n * By Alex Bell |  MIT License\n *\n * JS Parser for the string value that appears in markup <img srcset=\"here\">\n *\n * @returns Array [{url: _, d: _, w: _, h:_}, ...]\n *\n * Based super duper closely on the reference algorithm at:\n * https://html.spec.whatwg.org/multipage/embedded-content.html#parse-a-srcset-attribute\n *\n * Most comments are copied in directly from the spec\n * (except for comments in parens).\n */ (function(root, factory) {\n    if (true) {\n        // AMD. Register as an anonymous module.\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else {}\n})(void 0, function() {\n    // 1. Let input be the value passed to this algorithm.\n    return function(input) {\n        // UTILITY FUNCTIONS\n        // Manual is faster than RegEx\n        // http://bjorn.tipling.com/state-and-regular-expressions-in-javascript\n        // http://jsperf.com/whitespace-character/5\n        function isSpace(c) {\n            return c === \" \" || // space\n            c === \"\t\" || // horizontal tab\n            c === \"\\n\" || // new line\n            c === \"\\f\" || // form feed\n            c === \"\\r\"; // carriage return\n        }\n        function collectCharacters(regEx) {\n            var chars, match = regEx.exec(input.substring(pos));\n            if (match) {\n                chars = match[0];\n                pos += chars.length;\n                return chars;\n            }\n        }\n        var inputLength = input.length, // (Don't use \\s, to avoid matching non-breaking space)\n        regexLeadingSpaces = /^[ \\t\\n\\r\\u000c]+/, regexLeadingCommasOrSpaces = /^[, \\t\\n\\r\\u000c]+/, regexLeadingNotSpaces = /^[^ \\t\\n\\r\\u000c]+/, regexTrailingCommas = /[,]+$/, regexNonNegativeInteger = /^\\d+$/, // ( Positive or negative or unsigned integers or decimals, without or without exponents.\n        // Must include at least one digit.\n        // According to spec tests any decimal point must be followed by a digit.\n        // No leading plus sign is allowed.)\n        // https://html.spec.whatwg.org/multipage/infrastructure.html#valid-floating-point-number\n        regexFloatingPoint = /^-?(?:[0-9]+|[0-9]*\\.[0-9]+)(?:[eE][+-]?[0-9]+)?$/, url, descriptors, currentDescriptor, state, c, // 2. Let position be a pointer into input, initially pointing at the start\n        //    of the string.\n        pos = 0, // 3. Let candidates be an initially empty source set.\n        candidates = [];\n        // 4. Splitting loop: Collect a sequence of characters that are space\n        //    characters or U+002C COMMA characters. If any U+002C COMMA characters\n        //    were collected, that is a parse error.\n        while(true){\n            collectCharacters(regexLeadingCommasOrSpaces);\n            // 5. If position is past the end of input, return candidates and abort these steps.\n            if (pos >= inputLength) {\n                return candidates; // (we're done, this is the sole return path)\n            }\n            // 6. Collect a sequence of characters that are not space characters,\n            //    and let that be url.\n            url = collectCharacters(regexLeadingNotSpaces);\n            // 7. Let descriptors be a new empty list.\n            descriptors = [];\n            // 8. If url ends with a U+002C COMMA character (,), follow these substeps:\n            //\t\t(1). Remove all trailing U+002C COMMA characters from url. If this removed\n            //         more than one character, that is a parse error.\n            if (url.slice(-1) === \",\") {\n                url = url.replace(regexTrailingCommas, \"\");\n                // (Jump ahead to step 9 to skip tokenization and just push the candidate).\n                parseDescriptors();\n            //\tOtherwise, follow these substeps:\n            } else {\n                tokenize();\n            } // (close else of step 8)\n        // 16. Return to the step labeled splitting loop.\n        } // (Close of big while loop.)\n        /**\n\t\t * Tokenizes descriptor properties prior to parsing\n\t\t * Returns undefined.\n\t\t */ function tokenize() {\n            // 8.1. Descriptor tokeniser: Skip whitespace\n            collectCharacters(regexLeadingSpaces);\n            // 8.2. Let current descriptor be the empty string.\n            currentDescriptor = \"\";\n            // 8.3. Let state be in descriptor.\n            state = \"in descriptor\";\n            while(true){\n                // 8.4. Let c be the character at position.\n                c = input.charAt(pos);\n                //  Do the following depending on the value of state.\n                //  For the purpose of this step, \"EOF\" is a special character representing\n                //  that position is past the end of input.\n                // In descriptor\n                if (state === \"in descriptor\") {\n                    // Do the following, depending on the value of c:\n                    // Space character\n                    // If current descriptor is not empty, append current descriptor to\n                    // descriptors and let current descriptor be the empty string.\n                    // Set state to after descriptor.\n                    if (isSpace(c)) {\n                        if (currentDescriptor) {\n                            descriptors.push(currentDescriptor);\n                            currentDescriptor = \"\";\n                            state = \"after descriptor\";\n                        }\n                    // U+002C COMMA (,)\n                    // Advance position to the next character in input. If current descriptor\n                    // is not empty, append current descriptor to descriptors. Jump to the step\n                    // labeled descriptor parser.\n                    } else if (c === \",\") {\n                        pos += 1;\n                        if (currentDescriptor) {\n                            descriptors.push(currentDescriptor);\n                        }\n                        parseDescriptors();\n                        return;\n                    // U+0028 LEFT PARENTHESIS (()\n                    // Append c to current descriptor. Set state to in parens.\n                    } else if (c === \"(\") {\n                        currentDescriptor = currentDescriptor + c;\n                        state = \"in parens\";\n                    // EOF\n                    // If current descriptor is not empty, append current descriptor to\n                    // descriptors. Jump to the step labeled descriptor parser.\n                    } else if (c === \"\") {\n                        if (currentDescriptor) {\n                            descriptors.push(currentDescriptor);\n                        }\n                        parseDescriptors();\n                        return;\n                    // Anything else\n                    // Append c to current descriptor.\n                    } else {\n                        currentDescriptor = currentDescriptor + c;\n                    }\n                // (end \"in descriptor\"\n                // In parens\n                } else if (state === \"in parens\") {\n                    // U+0029 RIGHT PARENTHESIS ())\n                    // Append c to current descriptor. Set state to in descriptor.\n                    if (c === \")\") {\n                        currentDescriptor = currentDescriptor + c;\n                        state = \"in descriptor\";\n                    // EOF\n                    // Append current descriptor to descriptors. Jump to the step labeled\n                    // descriptor parser.\n                    } else if (c === \"\") {\n                        descriptors.push(currentDescriptor);\n                        parseDescriptors();\n                        return;\n                    // Anything else\n                    // Append c to current descriptor.\n                    } else {\n                        currentDescriptor = currentDescriptor + c;\n                    }\n                // After descriptor\n                } else if (state === \"after descriptor\") {\n                    // Do the following, depending on the value of c:\n                    // Space character: Stay in this state.\n                    if (isSpace(c)) {\n                    // EOF: Jump to the step labeled descriptor parser.\n                    } else if (c === \"\") {\n                        parseDescriptors();\n                        return;\n                    // Anything else\n                    // Set state to in descriptor. Set position to the previous character in input.\n                    } else {\n                        state = \"in descriptor\";\n                        pos -= 1;\n                    }\n                }\n                // Advance position to the next character in input.\n                pos += 1;\n            // Repeat this step.\n            } // (close while true loop)\n        }\n        /**\n\t\t * Adds descriptor properties to a candidate, pushes to the candidates array\n\t\t * @return undefined\n\t\t */ // Declared outside of the while loop so that it's only created once.\n        function parseDescriptors() {\n            // 9. Descriptor parser: Let error be no.\n            var pError = false, // 10. Let width be absent.\n            // 11. Let density be absent.\n            // 12. Let future-compat-h be absent. (We're implementing it now as h)\n            w, d, h, i, candidate = {}, desc, lastChar, value, intVal, floatVal;\n            // 13. For each descriptor in descriptors, run the appropriate set of steps\n            // from the following list:\n            for(i = 0; i < descriptors.length; i++){\n                desc = descriptors[i];\n                lastChar = desc[desc.length - 1];\n                value = desc.substring(0, desc.length - 1);\n                intVal = parseInt(value, 10);\n                floatVal = parseFloat(value);\n                // If the descriptor consists of a valid non-negative integer followed by\n                // a U+0077 LATIN SMALL LETTER W character\n                if (regexNonNegativeInteger.test(value) && lastChar === \"w\") {\n                    // If width and density are not both absent, then let error be yes.\n                    if (w || d) {\n                        pError = true;\n                    }\n                    // Apply the rules for parsing non-negative integers to the descriptor.\n                    // If the result is zero, let error be yes.\n                    // Otherwise, let width be the result.\n                    if (intVal === 0) {\n                        pError = true;\n                    } else {\n                        w = intVal;\n                    }\n                // If the descriptor consists of a valid floating-point number followed by\n                // a U+0078 LATIN SMALL LETTER X character\n                } else if (regexFloatingPoint.test(value) && lastChar === \"x\") {\n                    // If width, density and future-compat-h are not all absent, then let error\n                    // be yes.\n                    if (w || d || h) {\n                        pError = true;\n                    }\n                    // Apply the rules for parsing floating-point number values to the descriptor.\n                    // If the result is less than zero, let error be yes. Otherwise, let density\n                    // be the result.\n                    if (floatVal < 0) {\n                        pError = true;\n                    } else {\n                        d = floatVal;\n                    }\n                // If the descriptor consists of a valid non-negative integer followed by\n                // a U+0068 LATIN SMALL LETTER H character\n                } else if (regexNonNegativeInteger.test(value) && lastChar === \"h\") {\n                    // If height and density are not both absent, then let error be yes.\n                    if (h || d) {\n                        pError = true;\n                    }\n                    // Apply the rules for parsing non-negative integers to the descriptor.\n                    // If the result is zero, let error be yes. Otherwise, let future-compat-h\n                    // be the result.\n                    if (intVal === 0) {\n                        pError = true;\n                    } else {\n                        h = intVal;\n                    }\n                // Anything else, Let error be yes.\n                } else {\n                    pError = true;\n                }\n            } // (close step 13 for loop)\n            // 15. If error is still no, then append a new image source to candidates whose\n            // URL is url, associated with a width width if not absent and a pixel\n            // density density if not absent. Otherwise, there is a parse error.\n            if (!pError) {\n                candidate.url = url;\n                if (w) {\n                    candidate.w = w;\n                }\n                if (d) {\n                    candidate.d = d;\n                }\n                if (h) {\n                    candidate.h = h;\n                }\n                candidates.push(candidate);\n            } else if (console && console.log) {\n                console.log(\"Invalid srcset descriptor found in '\" + input + \"' at '\" + desc + \"'.\");\n            }\n        } // (close parseDescriptors fn)\n    };\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9wYXJzZS1zcmNzZXQvc3JjL3BhcnNlLXNyY3NldC5qcyIsIm1hcHBpbmdzIjoiO0FBQUE7Ozs7Ozs7Ozs7Ozs7O0NBY0MsR0FFQSxVQUFVQSxJQUFJLEVBQUVDLE9BQU87SUFDdkIsSUFBSSxJQUEwQyxFQUFFO1FBQy9DLHdDQUF3QztRQUN4Q0MsaUNBQU8sRUFBRSxvQ0FBRUQsT0FBT0E7QUFBQTtBQUFBO0FBQUEsa0dBQUNBO0lBQ3BCLE9BQU8sRUFRTjtBQUNGLEdBQUUsUUFBTTtJQUVQLHNEQUFzRDtJQUN0RCxPQUFPLFNBQVVNLEtBQUs7UUFFckIsb0JBQW9CO1FBRXBCLDhCQUE4QjtRQUM5Qix1RUFBdUU7UUFDdkUsMkNBQTJDO1FBQzNDLFNBQVNDLFFBQVFDLENBQUM7WUFDakIsT0FBUUEsTUFBTSxPQUFZLFFBQVE7WUFDbENBLE1BQU0sT0FBWSxpQkFBaUI7WUFDbkNBLE1BQU0sUUFBWSxXQUFXO1lBQzdCQSxNQUFNLFFBQVksWUFBWTtZQUM5QkEsTUFBTSxNQUFZLGtCQUFrQjtRQUNyQztRQUVBLFNBQVNDLGtCQUFrQkMsS0FBSztZQUMvQixJQUFJQyxPQUNIQyxRQUFRRixNQUFNRyxJQUFJLENBQUNQLE1BQU1RLFNBQVMsQ0FBQ0M7WUFDcEMsSUFBSUgsT0FBTztnQkFDVkQsUUFBUUMsS0FBSyxDQUFFLEVBQUc7Z0JBQ2xCRyxPQUFPSixNQUFNSyxNQUFNO2dCQUNuQixPQUFPTDtZQUNSO1FBQ0Q7UUFFQSxJQUFJTSxjQUFjWCxNQUFNVSxNQUFNLEVBRTdCLHVEQUF1RDtRQUN2REUscUJBQXFCLHFCQUNyQkMsNkJBQTZCLHNCQUM3QkMsd0JBQXdCLHNCQUN4QkMsc0JBQXNCLFNBQ3RCQywwQkFBMEIsU0FFMUIseUZBQXlGO1FBQ3pGLG1DQUFtQztRQUNuQyx5RUFBeUU7UUFDekUsb0NBQW9DO1FBQ3BDLHlGQUF5RjtRQUN6RkMscUJBQXFCLHFEQUVyQkMsS0FDQUMsYUFDQUMsbUJBQ0FDLE9B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OEJBQThCO0lBRWpDO0FBQ0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jb3Vyc2VfZ3JpZC8uL25vZGVfbW9kdWxlcy9wYXJzZS1zcmNzZXQvc3JjL3BhcnNlLXNyY3NldC5qcz9lZjgwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogU3Jjc2V0IFBhcnNlclxuICpcbiAqIEJ5IEFsZXggQmVsbCB8ICBNSVQgTGljZW5zZVxuICpcbiAqIEpTIFBhcnNlciBmb3IgdGhlIHN0cmluZyB2YWx1ZSB0aGF0IGFwcGVhcnMgaW4gbWFya3VwIDxpbWcgc3Jjc2V0PVwiaGVyZVwiPlxuICpcbiAqIEByZXR1cm5zIEFycmF5IFt7dXJsOiBfLCBkOiBfLCB3OiBfLCBoOl99LCAuLi5dXG4gKlxuICogQmFzZWQgc3VwZXIgZHVwZXIgY2xvc2VseSBvbiB0aGUgcmVmZXJlbmNlIGFsZ29yaXRobSBhdDpcbiAqIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2VtYmVkZGVkLWNvbnRlbnQuaHRtbCNwYXJzZS1hLXNyY3NldC1hdHRyaWJ1dGVcbiAqXG4gKiBNb3N0IGNvbW1lbnRzIGFyZSBjb3BpZWQgaW4gZGlyZWN0bHkgZnJvbSB0aGUgc3BlY1xuICogKGV4Y2VwdCBmb3IgY29tbWVudHMgaW4gcGFyZW5zKS5cbiAqL1xuXG4oZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIEFNRC4gUmVnaXN0ZXIgYXMgYW4gYW5vbnltb3VzIG1vZHVsZS5cblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHR9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzKSB7XG5cdFx0Ly8gTm9kZS4gRG9lcyBub3Qgd29yayB3aXRoIHN0cmljdCBDb21tb25KUywgYnV0XG5cdFx0Ly8gb25seSBDb21tb25KUy1saWtlIGVudmlyb25tZW50cyB0aGF0IHN1cHBvcnQgbW9kdWxlLmV4cG9ydHMsXG5cdFx0Ly8gbGlrZSBOb2RlLlxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHR9IGVsc2Uge1xuXHRcdC8vIEJyb3dzZXIgZ2xvYmFscyAocm9vdCBpcyB3aW5kb3cpXG5cdFx0cm9vdC5wYXJzZVNyY3NldCA9IGZhY3RvcnkoKTtcblx0fVxufSh0aGlzLCBmdW5jdGlvbiAoKSB7XG5cblx0Ly8gMS4gTGV0IGlucHV0IGJlIHRoZSB2YWx1ZSBwYXNzZWQgdG8gdGhpcyBhbGdvcml0aG0uXG5cdHJldHVybiBmdW5jdGlvbiAoaW5wdXQpIHtcblxuXHRcdC8vIFVUSUxJVFkgRlVOQ1RJT05TXG5cblx0XHQvLyBNYW51YWwgaXMgZmFzdGVyIHRoYW4gUmVnRXhcblx0XHQvLyBodHRwOi8vYmpvcm4udGlwbGluZy5jb20vc3RhdGUtYW5kLXJlZ3VsYXItZXhwcmVzc2lvbnMtaW4tamF2YXNjcmlwdFxuXHRcdC8vIGh0dHA6Ly9qc3BlcmYuY29tL3doaXRlc3BhY2UtY2hhcmFjdGVyLzVcblx0XHRmdW5jdGlvbiBpc1NwYWNlKGMpIHtcblx0XHRcdHJldHVybiAoYyA9PT0gXCJcXHUwMDIwXCIgfHwgLy8gc3BhY2Vcblx0XHRcdGMgPT09IFwiXFx1MDAwOVwiIHx8IC8vIGhvcml6b250YWwgdGFiXG5cdFx0XHRjID09PSBcIlxcdTAwMEFcIiB8fCAvLyBuZXcgbGluZVxuXHRcdFx0YyA9PT0gXCJcXHUwMDBDXCIgfHwgLy8gZm9ybSBmZWVkXG5cdFx0XHRjID09PSBcIlxcdTAwMERcIik7ICAvLyBjYXJyaWFnZSByZXR1cm5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBjb2xsZWN0Q2hhcmFjdGVycyhyZWdFeCkge1xuXHRcdFx0dmFyIGNoYXJzLFxuXHRcdFx0XHRtYXRjaCA9IHJlZ0V4LmV4ZWMoaW5wdXQuc3Vic3RyaW5nKHBvcykpO1xuXHRcdFx0aWYgKG1hdGNoKSB7XG5cdFx0XHRcdGNoYXJzID0gbWF0Y2hbIDAgXTtcblx0XHRcdFx0cG9zICs9IGNoYXJzLmxlbmd0aDtcblx0XHRcdFx0cmV0dXJuIGNoYXJzO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHZhciBpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aCxcblxuXHRcdFx0Ly8gKERvbid0IHVzZSBcXHMsIHRvIGF2b2lkIG1hdGNoaW5nIG5vbi1icmVha2luZyBzcGFjZSlcblx0XHRcdHJlZ2V4TGVhZGluZ1NwYWNlcyA9IC9eWyBcXHRcXG5cXHJcXHUwMDBjXSsvLFxuXHRcdFx0cmVnZXhMZWFkaW5nQ29tbWFzT3JTcGFjZXMgPSAvXlssIFxcdFxcblxcclxcdTAwMGNdKy8sXG5cdFx0XHRyZWdleExlYWRpbmdOb3RTcGFjZXMgPSAvXlteIFxcdFxcblxcclxcdTAwMGNdKy8sXG5cdFx0XHRyZWdleFRyYWlsaW5nQ29tbWFzID0gL1ssXSskLyxcblx0XHRcdHJlZ2V4Tm9uTmVnYXRpdmVJbnRlZ2VyID0gL15cXGQrJC8sXG5cblx0XHRcdC8vICggUG9zaXRpdmUgb3IgbmVnYXRpdmUgb3IgdW5zaWduZWQgaW50ZWdlcnMgb3IgZGVjaW1hbHMsIHdpdGhvdXQgb3Igd2l0aG91dCBleHBvbmVudHMuXG5cdFx0XHQvLyBNdXN0IGluY2x1ZGUgYXQgbGVhc3Qgb25lIGRpZ2l0LlxuXHRcdFx0Ly8gQWNjb3JkaW5nIHRvIHNwZWMgdGVzdHMgYW55IGRlY2ltYWwgcG9pbnQgbXVzdCBiZSBmb2xsb3dlZCBieSBhIGRpZ2l0LlxuXHRcdFx0Ly8gTm8gbGVhZGluZyBwbHVzIHNpZ24gaXMgYWxsb3dlZC4pXG5cdFx0XHQvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9pbmZyYXN0cnVjdHVyZS5odG1sI3ZhbGlkLWZsb2F0aW5nLXBvaW50LW51bWJlclxuXHRcdFx0cmVnZXhGbG9hdGluZ1BvaW50ID0gL14tPyg/OlswLTldK3xbMC05XSpcXC5bMC05XSspKD86W2VFXVsrLV0/WzAtOV0rKT8kLyxcblxuXHRcdFx0dXJsLFxuXHRcdFx0ZGVzY3JpcHRvcnMsXG5cdFx0XHRjdXJyZW50RGVzY3JpcHRvcixcblx0XHRcdHN0YXRlLFxuXHRcdFx0YyxcblxuXHRcdFx0Ly8gMi4gTGV0IHBvc2l0aW9uIGJlIGEgcG9pbnRlciBpbnRvIGlucHV0LCBpbml0aWFsbHkgcG9pbnRpbmcgYXQgdGhlIHN0YXJ0XG5cdFx0XHQvLyAgICBvZiB0aGUgc3RyaW5nLlxuXHRcdFx0cG9zID0gMCxcblxuXHRcdFx0Ly8gMy4gTGV0IGNhbmRpZGF0ZXMgYmUgYW4gaW5pdGlhbGx5IGVtcHR5IHNvdXJjZSBzZXQuXG5cdFx0XHRjYW5kaWRhdGVzID0gW107XG5cblx0XHQvLyA0LiBTcGxpdHRpbmcgbG9vcDogQ29sbGVjdCBhIHNlcXVlbmNlIG9mIGNoYXJhY3RlcnMgdGhhdCBhcmUgc3BhY2Vcblx0XHQvLyAgICBjaGFyYWN0ZXJzIG9yIFUrMDAyQyBDT01NQSBjaGFyYWN0ZXJzLiBJZiBhbnkgVSswMDJDIENPTU1BIGNoYXJhY3RlcnNcblx0XHQvLyAgICB3ZXJlIGNvbGxlY3RlZCwgdGhhdCBpcyBhIHBhcnNlIGVycm9yLlxuXHRcdHdoaWxlICh0cnVlKSB7XG5cdFx0XHRjb2xsZWN0Q2hhcmFjdGVycyhyZWdleExlYWRpbmdDb21tYXNPclNwYWNlcyk7XG5cblx0XHRcdC8vIDUuIElmIHBvc2l0aW9uIGlzIHBhc3QgdGhlIGVuZCBvZiBpbnB1dCwgcmV0dXJuIGNhbmRpZGF0ZXMgYW5kIGFib3J0IHRoZXNlIHN0ZXBzLlxuXHRcdFx0aWYgKHBvcyA+PSBpbnB1dExlbmd0aCkge1xuXHRcdFx0XHRyZXR1cm4gY2FuZGlkYXRlczsgLy8gKHdlJ3JlIGRvbmUsIHRoaXMgaXMgdGhlIHNvbGUgcmV0dXJuIHBhdGgpXG5cdFx0XHR9XG5cblx0XHRcdC8vIDYuIENvbGxlY3QgYSBzZXF1ZW5jZSBvZiBjaGFyYWN0ZXJzIHRoYXQgYXJlIG5vdCBzcGFjZSBjaGFyYWN0ZXJzLFxuXHRcdFx0Ly8gICAgYW5kIGxldCB0aGF0IGJlIHVybC5cblx0XHRcdHVybCA9IGNvbGxlY3RDaGFyYWN0ZXJzKHJlZ2V4TGVhZGluZ05vdFNwYWNlcyk7XG5cblx0XHRcdC8vIDcuIExldCBkZXNjcmlwdG9ycyBiZSBhIG5ldyBlbXB0eSBsaXN0LlxuXHRcdFx0ZGVzY3JpcHRvcnMgPSBbXTtcblxuXHRcdFx0Ly8gOC4gSWYgdXJsIGVuZHMgd2l0aCBhIFUrMDAyQyBDT01NQSBjaGFyYWN0ZXIgKCwpLCBmb2xsb3cgdGhlc2Ugc3Vic3RlcHM6XG5cdFx0XHQvL1x0XHQoMSkuIFJlbW92ZSBhbGwgdHJhaWxpbmcgVSswMDJDIENPTU1BIGNoYXJhY3RlcnMgZnJvbSB1cmwuIElmIHRoaXMgcmVtb3ZlZFxuXHRcdFx0Ly8gICAgICAgICBtb3JlIHRoYW4gb25lIGNoYXJhY3RlciwgdGhhdCBpcyBhIHBhcnNlIGVycm9yLlxuXHRcdFx0aWYgKHVybC5zbGljZSgtMSkgPT09IFwiLFwiKSB7XG5cdFx0XHRcdHVybCA9IHVybC5yZXBsYWNlKHJlZ2V4VHJhaWxpbmdDb21tYXMsIFwiXCIpO1xuXHRcdFx0XHQvLyAoSnVtcCBhaGVhZCB0byBzdGVwIDkgdG8gc2tpcCB0b2tlbml6YXRpb24gYW5kIGp1c3QgcHVzaCB0aGUgY2FuZGlkYXRlKS5cblx0XHRcdFx0cGFyc2VEZXNjcmlwdG9ycygpO1xuXG5cdFx0XHRcdC8vXHRPdGhlcndpc2UsIGZvbGxvdyB0aGVzZSBzdWJzdGVwczpcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRva2VuaXplKCk7XG5cdFx0XHR9IC8vIChjbG9zZSBlbHNlIG9mIHN0ZXAgOClcblxuXHRcdFx0Ly8gMTYuIFJldHVybiB0byB0aGUgc3RlcCBsYWJlbGVkIHNwbGl0dGluZyBsb29wLlxuXHRcdH0gLy8gKENsb3NlIG9mIGJpZyB3aGlsZSBsb29wLilcblxuXHRcdC8qKlxuXHRcdCAqIFRva2VuaXplcyBkZXNjcmlwdG9yIHByb3BlcnRpZXMgcHJpb3IgdG8gcGFyc2luZ1xuXHRcdCAqIFJldHVybnMgdW5kZWZpbmVkLlxuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIHRva2VuaXplKCkge1xuXG5cdFx0XHQvLyA4LjEuIERlc2NyaXB0b3IgdG9rZW5pc2VyOiBTa2lwIHdoaXRlc3BhY2Vcblx0XHRcdGNvbGxlY3RDaGFyYWN0ZXJzKHJlZ2V4TGVhZGluZ1NwYWNlcyk7XG5cblx0XHRcdC8vIDguMi4gTGV0IGN1cnJlbnQgZGVzY3JpcHRvciBiZSB0aGUgZW1wdHkgc3RyaW5nLlxuXHRcdFx0Y3VycmVudERlc2NyaXB0b3IgPSBcIlwiO1xuXG5cdFx0XHQvLyA4LjMuIExldCBzdGF0ZSBiZSBpbiBkZXNjcmlwdG9yLlxuXHRcdFx0c3RhdGUgPSBcImluIGRlc2NyaXB0b3JcIjtcblxuXHRcdFx0d2hpbGUgKHRydWUpIHtcblxuXHRcdFx0XHQvLyA4LjQuIExldCBjIGJlIHRoZSBjaGFyYWN0ZXIgYXQgcG9zaXRpb24uXG5cdFx0XHRcdGMgPSBpbnB1dC5jaGFyQXQocG9zKTtcblxuXHRcdFx0XHQvLyAgRG8gdGhlIGZvbGxvd2luZyBkZXBlbmRpbmcgb24gdGhlIHZhbHVlIG9mIHN0YXRlLlxuXHRcdFx0XHQvLyAgRm9yIHRoZSBwdXJwb3NlIG9mIHRoaXMgc3RlcCwgXCJFT0ZcIiBpcyBhIHNwZWNpYWwgY2hhcmFjdGVyIHJlcHJlc2VudGluZ1xuXHRcdFx0XHQvLyAgdGhhdCBwb3NpdGlvbiBpcyBwYXN0IHRoZSBlbmQgb2YgaW5wdXQuXG5cblx0XHRcdFx0Ly8gSW4gZGVzY3JpcHRvclxuXHRcdFx0XHRpZiAoc3RhdGUgPT09IFwiaW4gZGVzY3JpcHRvclwiKSB7XG5cdFx0XHRcdFx0Ly8gRG8gdGhlIGZvbGxvd2luZywgZGVwZW5kaW5nIG9uIHRoZSB2YWx1ZSBvZiBjOlxuXG5cdFx0XHRcdFx0Ly8gU3BhY2UgY2hhcmFjdGVyXG5cdFx0XHRcdFx0Ly8gSWYgY3VycmVudCBkZXNjcmlwdG9yIGlzIG5vdCBlbXB0eSwgYXBwZW5kIGN1cnJlbnQgZGVzY3JpcHRvciB0b1xuXHRcdFx0XHRcdC8vIGRlc2NyaXB0b3JzIGFuZCBsZXQgY3VycmVudCBkZXNjcmlwdG9yIGJlIHRoZSBlbXB0eSBzdHJpbmcuXG5cdFx0XHRcdFx0Ly8gU2V0IHN0YXRlIHRvIGFmdGVyIGRlc2NyaXB0b3IuXG5cdFx0XHRcdFx0aWYgKGlzU3BhY2UoYykpIHtcblx0XHRcdFx0XHRcdGlmIChjdXJyZW50RGVzY3JpcHRvcikge1xuXHRcdFx0XHRcdFx0XHRkZXNjcmlwdG9ycy5wdXNoKGN1cnJlbnREZXNjcmlwdG9yKTtcblx0XHRcdFx0XHRcdFx0Y3VycmVudERlc2NyaXB0b3IgPSBcIlwiO1xuXHRcdFx0XHRcdFx0XHRzdGF0ZSA9IFwiYWZ0ZXIgZGVzY3JpcHRvclwiO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBVKzAwMkMgQ09NTUEgKCwpXG5cdFx0XHRcdFx0XHQvLyBBZHZhbmNlIHBvc2l0aW9uIHRvIHRoZSBuZXh0IGNoYXJhY3RlciBpbiBpbnB1dC4gSWYgY3VycmVudCBkZXNjcmlwdG9yXG5cdFx0XHRcdFx0XHQvLyBpcyBub3QgZW1wdHksIGFwcGVuZCBjdXJyZW50IGRlc2NyaXB0b3IgdG8gZGVzY3JpcHRvcnMuIEp1bXAgdG8gdGhlIHN0ZXBcblx0XHRcdFx0XHRcdC8vIGxhYmVsZWQgZGVzY3JpcHRvciBwYXJzZXIuXG5cdFx0XHRcdFx0fSBlbHNlIGlmIChjID09PSBcIixcIikge1xuXHRcdFx0XHRcdFx0cG9zICs9IDE7XG5cdFx0XHRcdFx0XHRpZiAoY3VycmVudERlc2NyaXB0b3IpIHtcblx0XHRcdFx0XHRcdFx0ZGVzY3JpcHRvcnMucHVzaChjdXJyZW50RGVzY3JpcHRvcik7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRwYXJzZURlc2NyaXB0b3JzKCk7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdFx0XHRcdC8vIFUrMDAyOCBMRUZUIFBBUkVOVEhFU0lTICgoKVxuXHRcdFx0XHRcdFx0Ly8gQXBwZW5kIGMgdG8gY3VycmVudCBkZXNjcmlwdG9yLiBTZXQgc3RhdGUgdG8gaW4gcGFyZW5zLlxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoYyA9PT0gXCJcXHUwMDI4XCIpIHtcblx0XHRcdFx0XHRcdGN1cnJlbnREZXNjcmlwdG9yID0gY3VycmVudERlc2NyaXB0b3IgKyBjO1xuXHRcdFx0XHRcdFx0c3RhdGUgPSBcImluIHBhcmVuc1wiO1xuXG5cdFx0XHRcdFx0XHQvLyBFT0Zcblx0XHRcdFx0XHRcdC8vIElmIGN1cnJlbnQgZGVzY3JpcHRvciBpcyBub3QgZW1wdHksIGFwcGVuZCBjdXJyZW50IGRlc2NyaXB0b3IgdG9cblx0XHRcdFx0XHRcdC8vIGRlc2NyaXB0b3JzLiBKdW1wIHRvIHRoZSBzdGVwIGxhYmVsZWQgZGVzY3JpcHRvciBwYXJzZXIuXG5cdFx0XHRcdFx0fSBlbHNlIGlmIChjID09PSBcIlwiKSB7XG5cdFx0XHRcdFx0XHRpZiAoY3VycmVudERlc2NyaXB0b3IpIHtcblx0XHRcdFx0XHRcdFx0ZGVzY3JpcHRvcnMucHVzaChjdXJyZW50RGVzY3JpcHRvcik7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRwYXJzZURlc2NyaXB0b3JzKCk7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdFx0XHRcdC8vIEFueXRoaW5nIGVsc2Vcblx0XHRcdFx0XHRcdC8vIEFwcGVuZCBjIHRvIGN1cnJlbnQgZGVzY3JpcHRvci5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Y3VycmVudERlc2NyaXB0b3IgPSBjdXJyZW50RGVzY3JpcHRvciArIGM7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vIChlbmQgXCJpbiBkZXNjcmlwdG9yXCJcblxuXHRcdFx0XHRcdC8vIEluIHBhcmVuc1xuXHRcdFx0XHR9IGVsc2UgaWYgKHN0YXRlID09PSBcImluIHBhcmVuc1wiKSB7XG5cblx0XHRcdFx0XHQvLyBVKzAwMjkgUklHSFQgUEFSRU5USEVTSVMgKCkpXG5cdFx0XHRcdFx0Ly8gQXBwZW5kIGMgdG8gY3VycmVudCBkZXNjcmlwdG9yLiBTZXQgc3RhdGUgdG8gaW4gZGVzY3JpcHRvci5cblx0XHRcdFx0XHRpZiAoYyA9PT0gXCIpXCIpIHtcblx0XHRcdFx0XHRcdGN1cnJlbnREZXNjcmlwdG9yID0gY3VycmVudERlc2NyaXB0b3IgKyBjO1xuXHRcdFx0XHRcdFx0c3RhdGUgPSBcImluIGRlc2NyaXB0b3JcIjtcblxuXHRcdFx0XHRcdFx0Ly8gRU9GXG5cdFx0XHRcdFx0XHQvLyBBcHBlbmQgY3VycmVudCBkZXNjcmlwdG9yIHRvIGRlc2NyaXB0b3JzLiBKdW1wIHRvIHRoZSBzdGVwIGxhYmVsZWRcblx0XHRcdFx0XHRcdC8vIGRlc2NyaXB0b3IgcGFyc2VyLlxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoYyA9PT0gXCJcIikge1xuXHRcdFx0XHRcdFx0ZGVzY3JpcHRvcnMucHVzaChjdXJyZW50RGVzY3JpcHRvcik7XG5cdFx0XHRcdFx0XHRwYXJzZURlc2NyaXB0b3JzKCk7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdFx0XHRcdC8vIEFueXRoaW5nIGVsc2Vcblx0XHRcdFx0XHRcdC8vIEFwcGVuZCBjIHRvIGN1cnJlbnQgZGVzY3JpcHRvci5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Y3VycmVudERlc2NyaXB0b3IgPSBjdXJyZW50RGVzY3JpcHRvciArIGM7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gQWZ0ZXIgZGVzY3JpcHRvclxuXHRcdFx0XHR9IGVsc2UgaWYgKHN0YXRlID09PSBcImFmdGVyIGRlc2NyaXB0b3JcIikge1xuXG5cdFx0XHRcdFx0Ly8gRG8gdGhlIGZvbGxvd2luZywgZGVwZW5kaW5nIG9uIHRoZSB2YWx1ZSBvZiBjOlxuXHRcdFx0XHRcdC8vIFNwYWNlIGNoYXJhY3RlcjogU3RheSBpbiB0aGlzIHN0YXRlLlxuXHRcdFx0XHRcdGlmIChpc1NwYWNlKGMpKSB7XG5cblx0XHRcdFx0XHRcdC8vIEVPRjogSnVtcCB0byB0aGUgc3RlcCBsYWJlbGVkIGRlc2NyaXB0b3IgcGFyc2VyLlxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoYyA9PT0gXCJcIikge1xuXHRcdFx0XHRcdFx0cGFyc2VEZXNjcmlwdG9ycygpO1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHRcdFx0XHQvLyBBbnl0aGluZyBlbHNlXG5cdFx0XHRcdFx0XHQvLyBTZXQgc3RhdGUgdG8gaW4gZGVzY3JpcHRvci4gU2V0IHBvc2l0aW9uIHRvIHRoZSBwcmV2aW91cyBjaGFyYWN0ZXIgaW4gaW5wdXQuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHN0YXRlID0gXCJpbiBkZXNjcmlwdG9yXCI7XG5cdFx0XHRcdFx0XHRwb3MgLT0gMTtcblxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEFkdmFuY2UgcG9zaXRpb24gdG8gdGhlIG5leHQgY2hhcmFjdGVyIGluIGlucHV0LlxuXHRcdFx0XHRwb3MgKz0gMTtcblxuXHRcdFx0XHQvLyBSZXBlYXQgdGhpcyBzdGVwLlxuXHRcdFx0fSAvLyAoY2xvc2Ugd2hpbGUgdHJ1ZSBsb29wKVxuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIEFkZHMgZGVzY3JpcHRvciBwcm9wZXJ0aWVzIHRvIGEgY2FuZGlkYXRlLCBwdXNoZXMgdG8gdGhlIGNhbmRpZGF0ZXMgYXJyYXlcblx0XHQgKiBAcmV0dXJuIHVuZGVmaW5lZFxuXHRcdCAqL1xuXHRcdC8vIERlY2xhcmVkIG91dHNpZGUgb2YgdGhlIHdoaWxlIGxvb3Agc28gdGhhdCBpdCdzIG9ubHkgY3JlYXRlZCBvbmNlLlxuXHRcdGZ1bmN0aW9uIHBhcnNlRGVzY3JpcHRvcnMoKSB7XG5cblx0XHRcdC8vIDkuIERlc2NyaXB0b3IgcGFyc2VyOiBMZXQgZXJyb3IgYmUgbm8uXG5cdFx0XHR2YXIgcEVycm9yID0gZmFsc2UsXG5cblx0XHRcdFx0Ly8gMTAuIExldCB3aWR0aCBiZSBhYnNlbnQuXG5cdFx0XHRcdC8vIDExLiBMZXQgZGVuc2l0eSBiZSBhYnNlbnQuXG5cdFx0XHRcdC8vIDEyLiBMZXQgZnV0dXJlLWNvbXBhdC1oIGJlIGFic2VudC4gKFdlJ3JlIGltcGxlbWVudGluZyBpdCBub3cgYXMgaClcblx0XHRcdFx0dywgZCwgaCwgaSxcblx0XHRcdFx0Y2FuZGlkYXRlID0ge30sXG5cdFx0XHRcdGRlc2MsIGxhc3RDaGFyLCB2YWx1ZSwgaW50VmFsLCBmbG9hdFZhbDtcblxuXHRcdFx0Ly8gMTMuIEZvciBlYWNoIGRlc2NyaXB0b3IgaW4gZGVzY3JpcHRvcnMsIHJ1biB0aGUgYXBwcm9wcmlhdGUgc2V0IG9mIHN0ZXBzXG5cdFx0XHQvLyBmcm9tIHRoZSBmb2xsb3dpbmcgbGlzdDpcblx0XHRcdGZvciAoaSA9IDAgOyBpIDwgZGVzY3JpcHRvcnMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0ZGVzYyA9IGRlc2NyaXB0b3JzWyBpIF07XG5cblx0XHRcdFx0bGFzdENoYXIgPSBkZXNjWyBkZXNjLmxlbmd0aCAtIDEgXTtcblx0XHRcdFx0dmFsdWUgPSBkZXNjLnN1YnN0cmluZygwLCBkZXNjLmxlbmd0aCAtIDEpO1xuXHRcdFx0XHRpbnRWYWwgPSBwYXJzZUludCh2YWx1ZSwgMTApO1xuXHRcdFx0XHRmbG9hdFZhbCA9IHBhcnNlRmxvYXQodmFsdWUpO1xuXG5cdFx0XHRcdC8vIElmIHRoZSBkZXNjcmlwdG9yIGNvbnNpc3RzIG9mIGEgdmFsaWQgbm9uLW5lZ2F0aXZlIGludGVnZXIgZm9sbG93ZWQgYnlcblx0XHRcdFx0Ly8gYSBVKzAwNzcgTEFUSU4gU01BTEwgTEVUVEVSIFcgY2hhcmFjdGVyXG5cdFx0XHRcdGlmIChyZWdleE5vbk5lZ2F0aXZlSW50ZWdlci50ZXN0KHZhbHVlKSAmJiAobGFzdENoYXIgPT09IFwid1wiKSkge1xuXG5cdFx0XHRcdFx0Ly8gSWYgd2lkdGggYW5kIGRlbnNpdHkgYXJlIG5vdCBib3RoIGFic2VudCwgdGhlbiBsZXQgZXJyb3IgYmUgeWVzLlxuXHRcdFx0XHRcdGlmICh3IHx8IGQpIHtwRXJyb3IgPSB0cnVlO31cblxuXHRcdFx0XHRcdC8vIEFwcGx5IHRoZSBydWxlcyBmb3IgcGFyc2luZyBub24tbmVnYXRpdmUgaW50ZWdlcnMgdG8gdGhlIGRlc2NyaXB0b3IuXG5cdFx0XHRcdFx0Ly8gSWYgdGhlIHJlc3VsdCBpcyB6ZXJvLCBsZXQgZXJyb3IgYmUgeWVzLlxuXHRcdFx0XHRcdC8vIE90aGVyd2lzZSwgbGV0IHdpZHRoIGJlIHRoZSByZXN1bHQuXG5cdFx0XHRcdFx0aWYgKGludFZhbCA9PT0gMCkge3BFcnJvciA9IHRydWU7fSBlbHNlIHt3ID0gaW50VmFsO31cblxuXHRcdFx0XHRcdC8vIElmIHRoZSBkZXNjcmlwdG9yIGNvbnNpc3RzIG9mIGEgdmFsaWQgZmxvYXRpbmctcG9pbnQgbnVtYmVyIGZvbGxvd2VkIGJ5XG5cdFx0XHRcdFx0Ly8gYSBVKzAwNzggTEFUSU4gU01BTEwgTEVUVEVSIFggY2hhcmFjdGVyXG5cdFx0XHRcdH0gZWxzZSBpZiAocmVnZXhGbG9hdGluZ1BvaW50LnRlc3QodmFsdWUpICYmIChsYXN0Q2hhciA9PT0gXCJ4XCIpKSB7XG5cblx0XHRcdFx0XHQvLyBJZiB3aWR0aCwgZGVuc2l0eSBhbmQgZnV0dXJlLWNvbXBhdC1oIGFyZSBub3QgYWxsIGFic2VudCwgdGhlbiBsZXQgZXJyb3Jcblx0XHRcdFx0XHQvLyBiZSB5ZXMuXG5cdFx0XHRcdFx0aWYgKHcgfHwgZCB8fCBoKSB7cEVycm9yID0gdHJ1ZTt9XG5cblx0XHRcdFx0XHQvLyBBcHBseSB0aGUgcnVsZXMgZm9yIHBhcnNpbmcgZmxvYXRpbmctcG9pbnQgbnVtYmVyIHZhbHVlcyB0byB0aGUgZGVzY3JpcHRvci5cblx0XHRcdFx0XHQvLyBJZiB0aGUgcmVzdWx0IGlzIGxlc3MgdGhhbiB6ZXJvLCBsZXQgZXJyb3IgYmUgeWVzLiBPdGhlcndpc2UsIGxldCBkZW5zaXR5XG5cdFx0XHRcdFx0Ly8gYmUgdGhlIHJlc3VsdC5cblx0XHRcdFx0XHRpZiAoZmxvYXRWYWwgPCAwKSB7cEVycm9yID0gdHJ1ZTt9IGVsc2Uge2QgPSBmbG9hdFZhbDt9XG5cblx0XHRcdFx0XHQvLyBJZiB0aGUgZGVzY3JpcHRvciBjb25zaXN0cyBvZiBhIHZhbGlkIG5vbi1uZWdhdGl2ZSBpbnRlZ2VyIGZvbGxvd2VkIGJ5XG5cdFx0XHRcdFx0Ly8gYSBVKzAwNjggTEFUSU4gU01BTEwgTEVUVEVSIEggY2hhcmFjdGVyXG5cdFx0XHRcdH0gZWxzZSBpZiAocmVnZXhOb25OZWdhdGl2ZUludGVnZXIudGVzdCh2YWx1ZSkgJiYgKGxhc3RDaGFyID09PSBcImhcIikpIHtcblxuXHRcdFx0XHRcdC8vIElmIGhlaWdodCBhbmQgZGVuc2l0eSBhcmUgbm90IGJvdGggYWJzZW50LCB0aGVuIGxldCBlcnJvciBiZSB5ZXMuXG5cdFx0XHRcdFx0aWYgKGggfHwgZCkge3BFcnJvciA9IHRydWU7fVxuXG5cdFx0XHRcdFx0Ly8gQXBwbHkgdGhlIHJ1bGVzIGZvciBwYXJzaW5nIG5vbi1uZWdhdGl2ZSBpbnRlZ2VycyB0byB0aGUgZGVzY3JpcHRvci5cblx0XHRcdFx0XHQvLyBJZiB0aGUgcmVzdWx0IGlzIHplcm8sIGxldCBlcnJvciBiZSB5ZXMuIE90aGVyd2lzZSwgbGV0IGZ1dHVyZS1jb21wYXQtaFxuXHRcdFx0XHRcdC8vIGJlIHRoZSByZXN1bHQuXG5cdFx0XHRcdFx0aWYgKGludFZhbCA9PT0gMCkge3BFcnJvciA9IHRydWU7fSBlbHNlIHtoID0gaW50VmFsO31cblxuXHRcdFx0XHRcdC8vIEFueXRoaW5nIGVsc2UsIExldCBlcnJvciBiZSB5ZXMuXG5cdFx0XHRcdH0gZWxzZSB7cEVycm9yID0gdHJ1ZTt9XG5cdFx0XHR9IC8vIChjbG9zZSBzdGVwIDEzIGZvciBsb29wKVxuXG5cdFx0XHQvLyAxNS4gSWYgZXJyb3IgaXMgc3RpbGwgbm8sIHRoZW4gYXBwZW5kIGEgbmV3IGltYWdlIHNvdXJjZSB0byBjYW5kaWRhdGVzIHdob3NlXG5cdFx0XHQvLyBVUkwgaXMgdXJsLCBhc3NvY2lhdGVkIHdpdGggYSB3aWR0aCB3aWR0aCBpZiBub3QgYWJzZW50IGFuZCBhIHBpeGVsXG5cdFx0XHQvLyBkZW5zaXR5IGRlbnNpdHkgaWYgbm90IGFic2VudC4gT3RoZXJ3aXNlLCB0aGVyZSBpcyBhIHBhcnNlIGVycm9yLlxuXHRcdFx0aWYgKCFwRXJyb3IpIHtcblx0XHRcdFx0Y2FuZGlkYXRlLnVybCA9IHVybDtcblx0XHRcdFx0aWYgKHcpIHsgY2FuZGlkYXRlLncgPSB3O31cblx0XHRcdFx0aWYgKGQpIHsgY2FuZGlkYXRlLmQgPSBkO31cblx0XHRcdFx0aWYgKGgpIHsgY2FuZGlkYXRlLmggPSBoO31cblx0XHRcdFx0Y2FuZGlkYXRlcy5wdXNoKGNhbmRpZGF0ZSk7XG5cdFx0XHR9IGVsc2UgaWYgKGNvbnNvbGUgJiYgY29uc29sZS5sb2cpIHtcblx0XHRcdFx0Y29uc29sZS5sb2coXCJJbnZhbGlkIHNyY3NldCBkZXNjcmlwdG9yIGZvdW5kIGluICdcIiArXG5cdFx0XHRcdFx0aW5wdXQgKyBcIicgYXQgJ1wiICsgZGVzYyArIFwiJy5cIik7XG5cdFx0XHR9XG5cdFx0fSAvLyAoY2xvc2UgcGFyc2VEZXNjcmlwdG9ycyBmbilcblxuXHR9XG59KSk7XG4iXSwibmFtZXMiOlsicm9vdCIsImZhY3RvcnkiLCJkZWZpbmUiLCJhbWQiLCJtb2R1bGUiLCJleHBvcnRzIiwicGFyc2VTcmNzZXQiLCJpbnB1dCIsImlzU3BhY2UiLCJjIiwiY29sbGVjdENoYXJhY3RlcnMiLCJyZWdFeCIsImNoYXJzIiwibWF0Y2giLCJleGVjIiwic3Vic3RyaW5nIiwicG9zIiwibGVuZ3RoIiwiaW5wdXRMZW5ndGgiLCJyZWdleExlYWRpbmdTcGFjZXMiLCJyZWdleExlYWRpbmdDb21tYXNPclNwYWNlcyIsInJlZ2V4TGVhZGluZ05vdFNwYWNlcyIsInJlZ2V4VHJhaWxpbmdDb21tYXMiLCJyZWdleE5vbk5lZ2F0aXZlSW50ZWdlciIsInJlZ2V4RmxvYXRpbmdQb2ludCIsInVybCIsImRlc2NyaXB0b3JzIiwiY3VycmVudERlc2NyaXB0b3IiLCJzdGF0ZSIsImNhbmRpZGF0ZXMiLCJzbGljZSIsInJlcGxhY2UiLCJwYXJzZURlc2NyaXB0b3JzIiwidG9rZW5pemUiLCJjaGFyQXQiLCJwdXNoIiwicEVycm9yIiwidyIsImQiLCJoIiwiaSIsImNhbmRpZGF0ZSIsImRlc2MiLCJsYXN0Q2hhciIsInZhbHVlIiwiaW50VmFsIiwiZmxvYXRWYWwiLCJwYXJzZUludCIsInBhcnNlRmxvYXQiLCJ0ZXN0IiwiY29uc29sZSIsImxvZyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/parse-srcset/src/parse-srcset.js\n");

/***/ })

};
;